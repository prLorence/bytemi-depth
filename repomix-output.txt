This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-12T17:43:29.331Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
Assets/Scripts/Editor.meta
Assets/Scripts/Editor/UI.meta
Assets/Scripts/Editor/UI/LogObjectPoolEditor.cs
Assets/Scripts/Editor/UI/LogObjectPoolEditor.cs.meta
Assets/Scripts/Editor/UI/SelectImplementationDrawer.cs
Assets/Scripts/Editor/UI/SelectImplementationDrawer.cs.meta
Assets/Scripts/Editor/UI/TableLayoutEditor.cs
Assets/Scripts/Editor/UI/TableLayoutEditor.cs.meta
Assets/Scripts/Editor/UI/TouchableEditor.cs
Assets/Scripts/Editor/UI/TouchableEditor.cs.meta
Assets/Scripts/Editor/Unity.XR.ARFoundation.Samples.Editor.asmdef
Assets/Scripts/Editor/Unity.XR.ARFoundation.Samples.Editor.asmdef.meta
Assets/Scripts/Runtime.meta
Assets/Scripts/Runtime/CameraConfigController.cs
Assets/Scripts/Runtime/CameraConfigController.cs.meta
Assets/Scripts/Runtime/CaptureButton.cs
Assets/Scripts/Runtime/CaptureButton.cs.meta
Assets/Scripts/Runtime/CaptureManager.cs
Assets/Scripts/Runtime/CaptureManager.cs.meta
Assets/Scripts/Runtime/ControllerDeviceMonitor.cs
Assets/Scripts/Runtime/ControllerDeviceMonitor.cs.meta
Assets/Scripts/Runtime/CornerVisualizerSizeController.cs
Assets/Scripts/Runtime/CornerVisualizerSizeController.cs.meta
Assets/Scripts/Runtime/CpuImageSample.cs
Assets/Scripts/Runtime/CpuImageSample.cs.meta
Assets/Scripts/Runtime/DebugInfoDisplayController.cs
Assets/Scripts/Runtime/DebugInfoDisplayController.cs.meta
Assets/Scripts/Runtime/DepthImageExporter.cs
Assets/Scripts/Runtime/DepthImageExporter.cs.meta
Assets/Scripts/Runtime/DisplayDepthImage.cs
Assets/Scripts/Runtime/DisplayDepthImage.cs.meta
Assets/Scripts/Runtime/Logger.cs
Assets/Scripts/Runtime/Logger.cs.meta
Assets/Scripts/Runtime/Models.cs
Assets/Scripts/Runtime/Models.cs.meta
Assets/Scripts/Runtime/Multipeer.meta
Assets/Scripts/Runtime/Multipeer/MCSession.cs
Assets/Scripts/Runtime/Multipeer/MCSession.cs.meta
Assets/Scripts/Runtime/Multipeer/MCSessionSendDataMode.cs
Assets/Scripts/Runtime/Multipeer/MCSessionSendDataMode.cs.meta
Assets/Scripts/Runtime/Multipeer/NativeApi.cs
Assets/Scripts/Runtime/Multipeer/NativeApi.cs.meta
Assets/Scripts/Runtime/Multipeer/NativeCode.meta
Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate-C-Bridge.m
Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate-C-Bridge.m.meta
Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate.h
Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate.h.meta
Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate.m
Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate.m.meta
Assets/Scripts/Runtime/Multipeer/NativeCode/NSData-C-Bridge.m
Assets/Scripts/Runtime/Multipeer/NativeCode/NSData-C-Bridge.m.meta
Assets/Scripts/Runtime/Multipeer/NativeCode/NSError-C-Bridge.m
Assets/Scripts/Runtime/Multipeer/NativeCode/NSError-C-Bridge.m.meta
Assets/Scripts/Runtime/Multipeer/NativeCode/NSString-C-Bridge.m
Assets/Scripts/Runtime/Multipeer/NativeCode/NSString-C-Bridge.m.meta
Assets/Scripts/Runtime/Multipeer/NSData.cs
Assets/Scripts/Runtime/Multipeer/NSData.cs.meta
Assets/Scripts/Runtime/Multipeer/NSError.cs
Assets/Scripts/Runtime/Multipeer/NSError.cs.meta
Assets/Scripts/Runtime/Multipeer/NSErrorException.cs
Assets/Scripts/Runtime/Multipeer/NSErrorException.cs.meta
Assets/Scripts/Runtime/Multipeer/NSString.cs
Assets/Scripts/Runtime/Multipeer/NSString.cs.meta
Assets/Scripts/Runtime/Multipeer/Unity.XR.Samples.Multipeer.asmdef
Assets/Scripts/Runtime/Multipeer/Unity.XR.Samples.Multipeer.asmdef.meta
Assets/Scripts/Runtime/RGBImageCapture.cs
Assets/Scripts/Runtime/RGBImageCapture.cs.meta
Assets/Scripts/Runtime/ServerManager.cs
Assets/Scripts/Runtime/ServerManager.cs.meta
Assets/Scripts/Runtime/Triggers.meta
Assets/Scripts/Runtime/Triggers/RequirementsTrigger.cs
Assets/Scripts/Runtime/Triggers/RequirementsTrigger.cs.meta
Assets/Scripts/Runtime/UI.meta
Assets/Scripts/Runtime/UI/AnchorScrollViewEntry.cs
Assets/Scripts/Runtime/UI/AnchorScrollViewEntry.cs.meta
Assets/Scripts/Runtime/UI/BackButton.cs
Assets/Scripts/Runtime/UI/BackButton.cs.meta
Assets/Scripts/Runtime/UI/ButtonUtils.cs
Assets/Scripts/Runtime/UI/ButtonUtils.cs.meta
Assets/Scripts/Runtime/UI/ButtonUtilsComponent.cs
Assets/Scripts/Runtime/UI/ButtonUtilsComponent.cs.meta
Assets/Scripts/Runtime/UI/CameraConfigurationDropdown.cs
Assets/Scripts/Runtime/UI/CameraConfigurationDropdown.cs.meta
Assets/Scripts/Runtime/UI/CheckRenderLine.cs
Assets/Scripts/Runtime/UI/CheckRenderLine.cs.meta
Assets/Scripts/Runtime/UI/CheckRuntimeDepth.cs
Assets/Scripts/Runtime/UI/CheckRuntimeDepth.cs.meta
Assets/Scripts/Runtime/UI/ColorAsset.cs
Assets/Scripts/Runtime/UI/ColorAsset.cs.meta
Assets/Scripts/Runtime/UI/LoadingVisualizer.cs
Assets/Scripts/Runtime/UI/LoadingVisualizer.cs.meta
Assets/Scripts/Runtime/UI/LogObject.cs
Assets/Scripts/Runtime/UI/LogObject.cs.meta
Assets/Scripts/Runtime/UI/LogObjectPool.cs
Assets/Scripts/Runtime/UI/LogObjectPool.cs.meta
Assets/Scripts/Runtime/UI/MenuCategory.cs
Assets/Scripts/Runtime/UI/MenuCategory.cs.meta
Assets/Scripts/Runtime/UI/MenuFollowCamera.cs
Assets/Scripts/Runtime/UI/MenuFollowCamera.cs.meta
Assets/Scripts/Runtime/UI/MenuLoader.cs
Assets/Scripts/Runtime/UI/MenuLoader.cs.meta
Assets/Scripts/Runtime/UI/MenuSelector.cs
Assets/Scripts/Runtime/UI/MenuSelector.cs.meta
Assets/Scripts/Runtime/UI/MetaDisplayRefreshRateDropdown.cs
Assets/Scripts/Runtime/UI/MetaDisplayRefreshRateDropdown.cs.meta
Assets/Scripts/Runtime/UI/RadioButton.cs
Assets/Scripts/Runtime/UI/RadioButton.cs.meta
Assets/Scripts/Runtime/UI/RectTransformExtensions.cs
Assets/Scripts/Runtime/UI/RectTransformExtensions.cs.meta
Assets/Scripts/Runtime/UI/Requirements.meta
Assets/Scripts/Runtime/UI/Requirements/IBooleanExpression.cs
Assets/Scripts/Runtime/UI/Requirements/IBooleanExpression.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresAnchors.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresAnchors.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresArKitSession.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresArKitSession.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresARSubsystem.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresARSubsystem.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresBodyTracking.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresBodyTracking.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresBoundingBoxes.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresBoundingBoxes.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresCamera.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresCamera.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresEnvironmentProbes.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresEnvironmentProbes.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresFaceTracking.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresFaceTracking.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresImageTracking.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresImageTracking.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresMeshing.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresMeshing.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresObjectTracking.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresObjectTracking.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresOcclusion.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresOcclusion.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresParticipants.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresParticipants.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresPlaneDetection.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresPlaneDetection.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresPlatform.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresPlatform.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresPointClouds.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresPointClouds.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresRaycasts.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresRaycasts.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresSession.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresSession.cs.meta
Assets/Scripts/Runtime/UI/Requirements/RequiresVisualScripting.cs
Assets/Scripts/Runtime/UI/Requirements/RequiresVisualScripting.cs.meta
Assets/Scripts/Runtime/UI/Requirements/SampleSceneDescriptor.cs
Assets/Scripts/Runtime/UI/Requirements/SampleSceneDescriptor.cs.meta
Assets/Scripts/Runtime/UI/SceneLauncher.cs
Assets/Scripts/Runtime/UI/SceneLauncher.cs.meta
Assets/Scripts/Runtime/UI/ScreenOrientationLock.cs
Assets/Scripts/Runtime/UI/ScreenOrientationLock.cs.meta
Assets/Scripts/Runtime/UI/ScreenSpaceUIWorkaround.cs
Assets/Scripts/Runtime/UI/ScreenSpaceUIWorkaround.cs.meta
Assets/Scripts/Runtime/UI/SelectImplementationAttribute.cs
Assets/Scripts/Runtime/UI/SelectImplementationAttribute.cs.meta
Assets/Scripts/Runtime/UI/TableLayout.cs
Assets/Scripts/Runtime/UI/TableLayout.cs.meta
Assets/Scripts/Runtime/UI/TestAnchorScrollViewEntry.cs
Assets/Scripts/Runtime/UI/TestAnchorScrollViewEntry.cs.meta
Assets/Scripts/Runtime/UI/Tooltip.cs
Assets/Scripts/Runtime/UI/Tooltip.cs.meta
Assets/Scripts/Runtime/UI/Touchable.cs
Assets/Scripts/Runtime/UI/Touchable.cs.meta
Assets/Scripts/Runtime/UI/UIScrollViewVerticalScrollController.cs
Assets/Scripts/Runtime/UI/UIScrollViewVerticalScrollController.cs.meta
Assets/Scripts/Runtime/Unity.XR.ARFoundation.Samples.asmdef
Assets/Scripts/Runtime/Unity.XR.ARFoundation.Samples.asmdef.meta
Assets/Scripts/Runtime/Util.meta
Assets/Scripts/Runtime/Util/LogComponent.cs
Assets/Scripts/Runtime/Util/LogComponent.cs.meta
Assets/Scripts/Runtime/Util/OpenXRUtility.cs
Assets/Scripts/Runtime/Util/OpenXRUtility.cs.meta
Assets/Scripts/Runtime/Util/SubsystemsUtility.cs
Assets/Scripts/Runtime/Util/SubsystemsUtility.cs.meta
Assets/Scripts/Runtime/VisualScripting.meta
Assets/Scripts/Runtime/VisualScripting/AssemblyInfo.cs
Assets/Scripts/Runtime/VisualScripting/AssemblyInfo.cs.meta
Assets/Scripts/Runtime/VisualScripting/EventAssetEventUnit.cs
Assets/Scripts/Runtime/VisualScripting/EventAssetEventUnit.cs.meta
Assets/Scripts/Runtime/VisualScripting/PointerPressedEventUnit.cs
Assets/Scripts/Runtime/VisualScripting/PointerPressedEventUnit.cs.meta
Assets/Scripts/Runtime/VisualScripting/Unity.XR.ARFoundation.Samples.VisualScripting.asmdef
Assets/Scripts/Runtime/VisualScripting/Unity.XR.ARFoundation.Samples.VisualScripting.asmdef.meta
Assets/Scripts/Runtime/XROriginExtensions.cs
Assets/Scripts/Runtime/XROriginExtensions.cs.meta

================================================================
Repository Files
================================================================

================
File: Assets/Scripts/Editor.meta
================
fileFormatVersion: 2
guid: 6a1abe85e077b4721af57f4d6cd1cc5d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Editor/UI.meta
================
fileFormatVersion: 2
guid: 767150ee81d1140e985a4ec6056f0f95
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Editor/UI/LogObjectPoolEditor.cs
================
using TMPro;
using UnityEngine;
using UnityEngine.XR.ARFoundation.Samples;

namespace UnityEditor.XR.ARFoundation.Samples
{
    [CustomEditor(typeof(LogObjectPool))]
    public class LogObjectPoolEditor : Editor
    {
        SerializedProperty m_ScriptProp;
        SerializedProperty m_ScrollRectProp;
        SerializedProperty m_ScrollViewContentProp;
        SerializedProperty m_PoolSizeProp;
        SerializedProperty m_PoolProp;
        SerializedProperty m_TemplateObjectsProp;
        SerializedProperty m_ObjectHeightProp;

        void OnEnable()
        {
            m_ScriptProp = serializedObject.FindProperty("m_Script");
            m_ScrollRectProp = serializedObject.FindProperty("m_ScrollRect");
            m_ScrollViewContentProp = serializedObject.FindProperty("m_ScrollViewContent");
            m_PoolSizeProp = serializedObject.FindProperty("m_PoolSize");
            m_PoolProp = serializedObject.FindProperty("m_Pool");
            m_TemplateObjectsProp = serializedObject.FindProperty("m_TemplateObjects");
            m_ObjectHeightProp = serializedObject.FindProperty("m_ObjectHeight");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.PropertyField(m_ScriptProp);
            GUI.enabled = true;

            EditorGUILayout.PropertyField(m_ScrollRectProp);
            EditorGUILayout.PropertyField(m_ScrollViewContentProp);

            if (GUILayout.Button("Regenerate Object Pool"))
            {
                if (m_TemplateObjectsProp.arraySize == 0)
                {
                    Debug.LogError("Cannot regenerate Object Pool because the Template Objects list is empty.");
                    return;
                }

                float templateObjectHeight = -1;
                for (var i = 0; i < m_TemplateObjectsProp.arraySize; i++)
                {
                    var gameObject = m_TemplateObjectsProp.GetArrayElementAtIndex(i).objectReferenceValue as GameObject;
                    if (gameObject == null)
                    {
                        Debug.LogError("Cannot regenerate Object Pool because the Template Objects list" +
                            " contains a null GameObject.");

                        return;
                    }

                    var rect = gameObject.GetComponent<RectTransform>();
                    if (rect == null)
                    {
                        Debug.LogError("Cannot regenerate Object Pool because the Template Objects list"+
                            " contains a GameObject without a RectTransform component.");

                        return;
                    }

                    if (templateObjectHeight < 0)
                    {
                        templateObjectHeight = rect.GetHeight();
                    }
                    else if (rect.GetHeight() != templateObjectHeight)
                    {
                        Debug.LogError("Cannot regenerate Object Pool because the Template Objects list" +
                            " contains GameObjects with RectTransforms of non-equal height values.");

                        return;
                    }

                    if (gameObject.GetComponentInChildren<TextMeshProUGUI>() == null)
                    {
                        Debug.LogError("Cannot regenerate Object Pool because the Template Objects array" +
                            " contains a GameObject without a TextMeshProUGUI component in its children.");

                        return;
                    }
                }

                var transform = (serializedObject.targetObject as LogObjectPool)!.transform;
                var pool = transform.Find("Pool");
                if (pool == null)
                {
                    Debug.LogError("Please don't delete the Pool GameObject.");
                    return;
                }

                while (pool.childCount > 0)
                {
                    DestroyImmediate(pool.GetChild(0).gameObject);
                }

                int poolSize = m_PoolSizeProp.intValue;
                float poolHeight = 0;
                m_PoolProp.ClearArray();
                m_PoolProp.arraySize = poolSize;
                m_PoolProp.serializedObject.ApplyModifiedProperties();

                for (var i = 0; i < poolSize; i++)
                {
                    var poolObject = Instantiate(
                        m_TemplateObjectsProp.GetArrayElementAtIndex(i % m_TemplateObjectsProp.arraySize).objectReferenceValue as GameObject,
                        pool);

                    poolObject.name = $"Log Object {i}";

                    var rect = poolObject.GetComponent<RectTransform>();
                    rect.TranslateY(-poolHeight);
                    var height = rect.GetHeight();
                    poolHeight += height;
                    m_ObjectHeightProp.floatValue = height;

                    m_PoolProp.GetArrayElementAtIndex(i).objectReferenceValue = poolObject.GetComponentInChildren<TextMeshProUGUI>();
                }
            }

            GUILayout.Space(12);
            EditorGUILayout.PropertyField(m_PoolSizeProp);

            GUI.enabled = false;
            EditorGUILayout.PropertyField(m_PoolProp);
            GUI.enabled = true;

            EditorGUILayout.PropertyField(m_TemplateObjectsProp);

            serializedObject.ApplyModifiedProperties();
        }
    }
}

================
File: Assets/Scripts/Editor/UI/LogObjectPoolEditor.cs.meta
================
fileFormatVersion: 2
guid: c42b5403b3ecd43f19cefa33b2d5f6da
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Editor/UI/SelectImplementationDrawer.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using UnityEngine.XR.ARFoundation.Samples;

namespace UnityEditor.XR.ARFoundation.Samples
{
    [CustomPropertyDrawer(typeof(SelectImplementationAttribute))]
    public class SelectImplementationDrawer : PropertyDrawer
    {
        Type[] m_Implementations;
        string[] m_ImplementationNames;
        int m_SelectedNameIndex;

        static TypenameComparer s_Comparer = new();

        public override float GetPropertyHeight(SerializedProperty property, GUIContent label) => 0;

        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            if (m_Implementations == null)
            {
                m_Implementations = TypeCache.GetTypesDerivedFrom(
                    (attribute as SelectImplementationAttribute)!.fieldType)
                    .Where(t => t.IsPublic && !t.IsAbstract && !t.IsInterface)
                    .ToArray();

                Array.Sort(m_Implementations, s_Comparer);

                m_ImplementationNames = new string[m_Implementations.Length + 1];
                m_ImplementationNames[0] = m_Implementations.Length > 0 ? "Choose a Type" : "No implementations available";

                for (var i = 0; i < m_Implementations.Length; i++)
                {
                    m_ImplementationNames[i + 1] = m_Implementations[i].Name;
                }
            }

            if (property.managedReferenceValue != null)
            {
                var instanceType = property.managedReferenceValue.GetType();

                var i = 1; // accounts for default "Choose a Type" option
                foreach (var t in m_Implementations)
                {
                    if (string.Equals(t.Name, instanceType.Name))
                    {
                        m_SelectedNameIndex = i; 
                        break;
                    }

                    i++;
                }
            }
            else
            {
                m_SelectedNameIndex = 0;
            }

            var selectedIndex = EditorGUILayout.Popup("Type", m_SelectedNameIndex, m_ImplementationNames);
            if (selectedIndex == 0)
            {
                property.managedReferenceValue = null;
            }
            else if (m_SelectedNameIndex != selectedIndex)
            {
                property.managedReferenceValue = Activator.CreateInstance(m_Implementations[selectedIndex - 1]);
                m_SelectedNameIndex = selectedIndex;
            }

            var childEnumerator = property.GetEnumerator();
            while (childEnumerator.MoveNext())
            {
                var childProperty = childEnumerator.Current as SerializedProperty;
                if (childProperty!.depth > 2)
                    continue;

                EditorGUILayout.PropertyField(childEnumerator.Current as SerializedProperty);
            }
        }
    }

    class TypenameComparer : IComparer<Type>
    {
        int IComparer<Type>.Compare(Type x, Type y)
        {
            return string.Compare(x?.FullName, y?.FullName);
        }
    }
}

================
File: Assets/Scripts/Editor/UI/SelectImplementationDrawer.cs.meta
================
fileFormatVersion: 2
guid: 61f740de7b78b4afcb2f6ae9ceaf425e

================
File: Assets/Scripts/Editor/UI/TableLayoutEditor.cs
================
using System;
using UnityEngine;
using UnityEngine.XR.ARFoundation.Samples;

namespace UnityEditor.XR.ARFoundation.Samples
{
    [CustomEditor(typeof(TableLayout))]
    public class TableLayoutEditor : Editor
    {
        SerializedProperty m_ScriptProp;
        SerializedProperty m_CellsProp;
        SerializedProperty m_AlignmentProp;
        SerializedProperty m_ColumnsProp;
        SerializedProperty m_CellWidthProp;
        SerializedProperty m_CellHeightProp;
        SerializedProperty m_CellPaddingProp;

        void OnEnable()
        {
            m_ScriptProp = serializedObject.FindProperty("m_Script");
            m_CellsProp = serializedObject.FindProperty("m_Cells");
            m_AlignmentProp = serializedObject.FindProperty("m_Alignment");
            m_ColumnsProp = serializedObject.FindProperty("m_Columns");
            m_CellWidthProp = serializedObject.FindProperty("m_CellWidth");
            m_CellHeightProp = serializedObject.FindProperty("m_CellHeight");
            m_CellPaddingProp = serializedObject.FindProperty("m_CellPadding");
        }

        public override void OnInspectorGUI()
        {
            serializedObject.Update();

            GUI.enabled = false;
            EditorGUILayout.PropertyField(m_ScriptProp);
            GUI.enabled = true;

            EditorGUILayout.PropertyField(m_CellsProp);
            if (GUILayout.Button("Refresh from children"))
            {
                PopulateCellsFromChildren();
            }

            GUILayout.Space(12);
            EditorGUILayout.LabelField("Layout", EditorStyles.boldLabel);
            EditorGUILayout.PropertyField(m_AlignmentProp);
            EditorGUILayout.PropertyField(m_ColumnsProp);
            EditorGUILayout.PropertyField(m_CellWidthProp);
            EditorGUILayout.PropertyField(m_CellHeightProp);
            EditorGUILayout.PropertyField(m_CellPaddingProp);

            serializedObject.ApplyModifiedProperties();
        }

        void PopulateCellsFromChildren()
        {
            var transform = (serializedObject.targetObject as TableLayout)!.transform;
            var childCount = transform.childCount;

            var iterator = m_CellsProp.Copy();
            iterator.Next(true); // advance to generic field
            iterator.Next(true); // advance to array size field

            m_CellsProp.ClearArray();
            iterator.intValue = childCount;
            iterator.Next(true); // advance to first array index
            
            var lastIndex = childCount - 1;
            for (var i = 0; i < childCount; i++)
            {
                var child = transform.GetChild(i);
                var rect = child.GetComponent<RectTransform>();
                if (rect == null)
                {
                    Debug.LogWarning($"{child.name} is missing a RectTransform component. Add the component and try again?");
                    continue;
                }

                iterator.objectReferenceValue = rect;

                if (i < lastIndex)
                    iterator.Next(false); // advance through array
            }
        }
    }
}

================
File: Assets/Scripts/Editor/UI/TableLayoutEditor.cs.meta
================
fileFormatVersion: 2
guid: 20b948a8e92074a798465d30943e4e9c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Editor/UI/TouchableEditor.cs
================
using UnityEngine;
using UnityEngine.XR.ARFoundation.Samples;

namespace UnityEditor.XR.ARFoundation.Samples
{
    [CustomEditor(typeof(Touchable))]
    public class TouchableEditor : Editor
    {
        public override void OnInspectorGUI()
        {
            // Do nothing.
        }
    }
}

================
File: Assets/Scripts/Editor/UI/TouchableEditor.cs.meta
================
fileFormatVersion: 2
guid: ba066b59ce75c4cab9956ca84f48d349

================
File: Assets/Scripts/Editor/Unity.XR.ARFoundation.Samples.Editor.asmdef
================
{
    "name": "Unity.XR.ARFoundation.Samples.Editor",
    "rootNamespace": "UnityEditor.XR.ARFoundation.Samples",
    "references": [
        "Unity.XR.ARFoundation.Samples",
        "Unity.TextMeshPro"
    ],
    "includePlatforms": [
        "Editor"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [],
    "noEngineReferences": false
}

================
File: Assets/Scripts/Editor/Unity.XR.ARFoundation.Samples.Editor.asmdef.meta
================
fileFormatVersion: 2
guid: 6e6493d50b4b14321962b81dca98622f
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime.meta
================
fileFormatVersion: 2
guid: e0b8927a5552440f9bdb208c3d763f2d
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/CameraConfigController.cs
================
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Populates a drop down UI element with all the supported
    /// camera configurations and changes the active camera
    /// configuration when the user changes the selection in the dropdown.
    ///
    /// The camera configuration affects the resolution (and possibly framerate)
    /// of the hardware camera during an AR session.
    /// </summary>
    [RequireComponent(typeof(Dropdown))]
    public class CameraConfigController : MonoBehaviour
    {
        List<string> m_ConfigurationNames;

        Dropdown m_Dropdown;

        [SerializeField]
        [Tooltip("The ARCameraManager which will produce frame events.")]
        ARCameraManager m_CameraManager;

        /// <summary>
        /// Get or set the <c>ARCameraManager</c>.
        /// </summary>
        public ARCameraManager cameraManager
        {
            get => m_CameraManager;
            set => m_CameraManager = value;
        }

        /// <summary>
        /// Callback invoked when <see cref="m_Dropdown"/> changes. This
        /// lets us change the camera configuration when the user changes
        /// the selection in the UI.
        /// </summary>
        /// <param name="dropdown">The <c>Dropdown</c> which changed.</param>
        void OnDropdownValueChanged(Dropdown dropdown)
        {
            if ((cameraManager == null) || (cameraManager.subsystem == null) || !cameraManager.subsystem.running)
            {
                return;
            }

            var configurationIndex = dropdown.value;

            // Check that the value makes sense
            using (var configurations = cameraManager.GetConfigurations(Allocator.Temp))
            {
                if (configurationIndex >= configurations.Length)
                {
                    return;
                }

                // Get that configuration by index
                var configuration = configurations[configurationIndex];

                // Make it the active one
                cameraManager.currentConfiguration = configuration;
            }
        }

        void Awake()
        {
            m_Dropdown = GetComponent<Dropdown>();
            m_Dropdown.ClearOptions();
            m_Dropdown.onValueChanged.AddListener(delegate { OnDropdownValueChanged(m_Dropdown); });
            m_ConfigurationNames = new List<string>();
        }

        void PopulateDropdown()
        {
            if ((cameraManager == null) || (cameraManager.subsystem == null) || !cameraManager.subsystem.running)
                return;

            // No configurations available probably means this feature
            // isn't supported by the current device.
            using (var configurations = cameraManager.GetConfigurations(Allocator.Temp))
            {
                if (!configurations.IsCreated || (configurations.Length <= 0))
                {
                    return;
                }

                // There are two ways to enumerate the camera configurations.

                // 1. Use a foreach to iterate over all the available configurations
                foreach (var config in configurations)
                {
                    m_ConfigurationNames.Add($"{config.width}x{config.height}{(config.framerate.HasValue ? $" at {config.framerate.Value} Hz" : "")}{(config.depthSensorSupported == Supported.Supported ? " depth sensor" : "")}");
                }
                m_Dropdown.AddOptions(m_ConfigurationNames);

                // 2. Use a normal for...loop
                var currentConfig = cameraManager.currentConfiguration;
                for (int i = 0; i < configurations.Length; ++i)
                {
                    // Find the current configuration and update the drop down value
                    if (currentConfig == configurations[i])
                    {
                        m_Dropdown.value = i;
                    }
                }
            }
        }

        void Update()
        {
            if (m_ConfigurationNames.Count == 0)
                PopulateDropdown();
        }
    }
}

================
File: Assets/Scripts/Runtime/CameraConfigController.cs.meta
================
fileFormatVersion: 2
guid: 94b653a1faa6f4749ad83e77bcddfab4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/CaptureButton.cs
================
using UnityEngine;
using UnityEngine.UI;

// In your UI or button handler script
public class CaptureButton : MonoBehaviour
{
    [SerializeField]
    private Button captureButton;
    private DepthImageExporter depthExporter;
    private RGBImageCapture rgbImageCapture;

    void Start()
    {
        // Find the DepthImageExporter in the scene
        depthExporter = Object.FindFirstObjectByType<DepthImageExporter>();
        rgbImageCapture = Object.FindFirstObjectByType<RGBImageCapture>();

        // Setup button click handler
        captureButton.onClick.AddListener(OnCaptureButtonPressed);
    }

    void OnCaptureButtonPressed()
    {
        if (depthExporter != null)
        {
            depthExporter.CaptureDepthFrame();
        }

        if (rgbImageCapture != null)
        {
            rgbImageCapture.CaptureRGBFrame();
        }
    }
}

================
File: Assets/Scripts/Runtime/CaptureButton.cs.meta
================
fileFormatVersion: 2
guid: ff62391b6709fed45978240ca9cc8d04

================
File: Assets/Scripts/Runtime/CaptureManager.cs
================
using System;
using System.IO;
using System.Threading.Tasks;
using UnityEngine;
using UnityEngine.UI;

public class CaptureManager : MonoBehaviour
{
    [SerializeField] private DepthImageExporter depthExporter;
    [SerializeField] private RGBImageCapture rgbCapture;
    [SerializeField] private ServerManager serverManager;
    [SerializeField] private Button captureButton;

    private bool isCapturing = false;

    private void Start()
    {
        if (captureButton != null)
        {
            captureButton.onClick.AddListener(CaptureFrames);
        }

        ValidateComponents();
    }

    private void ValidateComponents()
    {
        if (depthExporter == null)
            Debug.LogError("DepthImageExporter not assigned!");
        if (rgbCapture == null)
            Debug.LogError("RGBImageCapture not assigned!");
    }

    private async void CaptureFrames()
    {
        if (isCapturing)
        {
            Debug.Log("Already capturing, please wait...");
            return;
        }

        try
        {
            isCapturing = true;
            captureButton.interactable = false;

            // Create parameters with consistent timestamp
            ServerManager.UploadParameters uploadParameters = new()
            {
                timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss"),
                basePath = Application.persistentDataPath,
                depthPrefix = "depth_frame_",
                rgbPrefix = "rgb_frame_"
            };

            Debug.Log($"Starting capture sequence with timestamp: {uploadParameters.timestamp}");

            // Ensure the directory exists
            Directory.CreateDirectory(uploadParameters.basePath);

            // Capture both frames
            depthExporter.CaptureDepthFrame();
            rgbCapture.CaptureRGBFrame();

            // Add small delay to ensure files are written
            await Task.Delay(1000);

            // Let server manager handle the upload
            if (serverManager != null)
            {
                await serverManager.UploadDepthData(uploadParameters);
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Error during capture: {e.Message}");
        }
        finally
        {
            isCapturing = false;
            captureButton.interactable = true;
        }
    }
}

================
File: Assets/Scripts/Runtime/CaptureManager.cs.meta
================
fileFormatVersion: 2
guid: b9d18cb4414b248438401421eae46fc2

================
File: Assets/Scripts/Runtime/ControllerDeviceMonitor.cs
================
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.XR;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Monitors an <see cref="XRController"/> and activates or deactivates a GameObject whenever the controller is
    /// enabled or disabled, respectively.
    /// </summary>
    public class ControllerDeviceMonitor : MonoBehaviour
    {
        [SerializeField]
        [Tooltip("The controller device to monitor. Choose either LeftHand or RightHand.")]
        XRNode m_ControllerDevice = XRNode.RightHand;

        [SerializeField]
        [Tooltip("The GameObject to activate or deactivate when the controller device is enabled or disabled, respectively.")]
        GameObject m_DeviceGameObject;

        /// <summary>
        /// The controller device to monitor. Valid values are either <c>LeftHand</c> or <c>RightHand</c>.
        /// </summary>
        public XRNode controllerDevice
        {
            get => m_ControllerDevice;
            set => m_ControllerDevice = value;
        }

        /// <summary>
        /// The GameObject to activate or deactivate when the controller device is enabled or disabled, respectively.
        /// </summary>
        public GameObject deviceGameObject
        {
            get => m_DeviceGameObject;
            set => m_DeviceGameObject = value;
        }

        void OnEnable()
        {
            UpdateDeviceGameObject(GetXRController());
            InputSystem.InputSystem.onDeviceChange += ProcessDeviceChange;
        }

        void OnDisable()
        {
            InputSystem.InputSystem.onDeviceChange -= ProcessDeviceChange;
        }

        void ProcessDeviceChange(InputSystem.InputDevice inputDevice, InputDeviceChange change)
        {
            var xrController = GetXRController();
            if (xrController != null && inputDevice != xrController)
                return;

            switch (change)
            {
                case InputDeviceChange.Added:
                case InputDeviceChange.Removed:
                case InputDeviceChange.Disconnected:
                case InputDeviceChange.Reconnected:
                case InputDeviceChange.Enabled:
                case InputDeviceChange.Disabled:
                    UpdateDeviceGameObject(xrController);
                    break;
                default:
                    break;
            }
        }

        XRController GetXRController()
        {
            switch (m_ControllerDevice)
            {
                case XRNode.LeftHand:
                    return XRController.leftHand;
                case XRNode.RightHand:
                    return XRController.rightHand;
                default:
                    return null;
            }
        }

        void UpdateDeviceGameObject(XRController deviceToCheck)
        {
            bool controllerState = deviceToCheck is {enabled: true};
            if (m_DeviceGameObject != null && controllerState != m_DeviceGameObject.activeSelf)
            {
                m_DeviceGameObject.SetActive(controllerState);
            }
        }
    }
}

================
File: Assets/Scripts/Runtime/ControllerDeviceMonitor.cs.meta
================
fileFormatVersion: 2
guid: 436414ffea2d4f24d80bf774814f86bf
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/CornerVisualizerSizeController.cs
================
using System;
using UnityEngine;
using UnityEngine.Serialization;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class CornerVisualizerSizeController : MonoBehaviour
    {
        [FormerlySerializedAs("m_CornerAxis")]
        [SerializeField]
        Transform m_XAxis;

        [SerializeField]
        Transform m_YAxis;

        [SerializeField]
        Transform m_ZAxis;

        float m_DefaultLength;
        float m_Sign;

        void Reset()
        {
            if (m_XAxis != null)
                m_DefaultLength = m_XAxis.localScale.x;
        }

        void Awake()
        {
            if (m_XAxis == null)
                Debug.Log($"{nameof(m_XAxis)} is null.");

            if (m_YAxis == null)
                Debug.Log($"{nameof(m_YAxis)} is null.");

            if (m_ZAxis == null)
                Debug.Log($"{nameof(m_ZAxis)} is null.");

            if (m_XAxis != null)
                m_DefaultLength = m_XAxis.localScale.x;

            if (m_XAxis != null)
                m_Sign = m_XAxis.localPosition.x > 0 ? 1 : -1;
        }

        public void SetMaxLength(float length)
        {
            SetXAxisVisualizer(length);
            SetYAxisVisualizer(length);
            SetZAxisVisualizer(length);
        }

        void SetXAxisVisualizer(float length)
        {
            if (length < m_DefaultLength)
            {
                var size = m_XAxis.localScale;
                size.x = length;
                m_XAxis.localScale = size;

                var position = m_XAxis.localPosition;
                position.x = m_XAxis.localScale.x * 0.5f * m_Sign;
                m_XAxis.localPosition = position;
            }
            else
            {

                var size = m_XAxis.localScale;
                size.x = m_DefaultLength;
                m_XAxis.localScale = size;

                var position = m_XAxis.localPosition;
                position.x = m_XAxis.localScale.x * 0.5f * m_Sign;
                m_XAxis.localPosition = position;
            }
        }
        
        void SetYAxisVisualizer(float length)
        {
            if (length < m_DefaultLength)
            {
                var size = m_YAxis.localScale;
                size.y = length;
                m_YAxis.localScale = size;

                var position = m_YAxis.localPosition;
                position.y = m_YAxis.localScale.y * 0.5f * m_Sign;
                m_YAxis.localPosition = position;
            }
            else
            {
                var size = m_YAxis.localScale;
                size.y = m_DefaultLength;
                m_YAxis.localScale = size;

                var position = m_YAxis.localPosition;
                position.y = m_YAxis.localScale.y * 0.5f * m_Sign;
                m_YAxis.localPosition = position;
            }
        }

        void SetZAxisVisualizer(float length)
        {
            if (length < m_DefaultLength)
            {
                var size = m_ZAxis.localScale;
                size.z = length;
                m_ZAxis.localScale = size;

                var position = m_ZAxis.localPosition;
                position.z = m_ZAxis.localScale.z * 0.5f * m_Sign;
                m_ZAxis.localPosition = position;
            }
            else
            {
                var size = m_ZAxis.localScale;
                size.z = m_DefaultLength;
                m_ZAxis.localScale = size;

                var position = m_ZAxis.localPosition;
                position.z = m_ZAxis.localScale.z * 0.5f * m_Sign;
                m_ZAxis.localPosition = position;
            }
        }
    }
}

================
File: Assets/Scripts/Runtime/CornerVisualizerSizeController.cs.meta
================
fileFormatVersion: 2
guid: 9e9a20c2f2df343c384b6a46f9ebf931

================
File: Assets/Scripts/Runtime/CpuImageSample.cs
================
using System;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// <para>This component tests getting the latest camera image and converting it to RGBA format. If successful,
    /// it displays the image on the screen as a Raw Image and also displays information about the image.
    /// This is useful for computer vision applications where you need to access the raw pixels from camera image
    /// on the CPU.</para>
    /// <para>This is different from the ARCameraBackground component, which efficiently displays the camera image on the screen.
    /// If you just want to blit the camera texture to the screen, use the ARCameraBackground, or use Graphics.Blit to create
    /// a GPU-friendly RenderTexture.</para>
    /// <para>In this example, we get the camera image data on the CPU, convert it to an RGBA format, then display it on the screen
    /// as a RawImage texture to demonstrate it is working. This is done as an example; do not use this technique simply
    /// to render the camera image on screen.</para>
    /// </summary>
    public class CpuImageSample : MonoBehaviour
    {
        Texture2D m_CameraTexture;
        XRCpuImage.Transformation m_Transformation = XRCpuImage.Transformation.MirrorY;

        [SerializeField]
        [Tooltip("The ARCameraManager which will produce frame events.")]
        ARCameraManager m_CameraManager;

        [SerializeField]
        [Tooltip("The AROcclusionManager which will produce human depth and stencil textures.")]
        AROcclusionManager m_OcclusionManager;

        [SerializeField]
        RawImage m_RawCameraImage;

        /// <summary>
        /// Get or set the UI RawImage used to display the image on screen.
        /// </summary>
        public RawImage rawCameraImage
        {
            get => m_RawCameraImage;
            set => m_RawCameraImage = value;
        }

        [SerializeField]
        RawImage m_RawHumanDepthImage;

        /// <summary>
        /// The UI RawImage used to display the image on screen.
        /// </summary>
        public RawImage rawHumanDepthImage
        {
            get => m_RawHumanDepthImage;
            set => m_RawHumanDepthImage = value;
        }

        [SerializeField]
        RawImage m_RawHumanStencilImage;

        /// <summary>
        /// The UI RawImage used to display the image on screen.
        /// </summary>
        public RawImage rawHumanStencilImage
        {
            get => m_RawHumanStencilImage;
            set => m_RawHumanStencilImage = value;
        }

        [SerializeField]
        RawImage m_RawEnvironmentDepthImage;

        /// <summary>
        /// The UI RawImage used to display the image on screen.
        /// </summary>
        public RawImage rawEnvironmentDepthImage
        {
            get => m_RawEnvironmentDepthImage;
            set => m_RawEnvironmentDepthImage = value;
        }

        [SerializeField]
        RawImage m_RawEnvironmentDepthConfidenceImage;

        /// <summary>
        /// The UI RawImage used to display the image on screen.
        /// </summary>
        public RawImage rawEnvironmentDepthConfidenceImage
        {
            get => m_RawEnvironmentDepthConfidenceImage;
            set => m_RawEnvironmentDepthConfidenceImage = value;
        }

        [SerializeField]
        Text m_ImageInfo;

        /// <summary>
        /// The UI Text used to display information about the image on screen.
        /// </summary>
        public Text imageInfo
        {
            get => m_ImageInfo;
            set => m_ImageInfo = value;
        }

        [HideInInspector]
        [SerializeField]
        Button m_TransformationButton;

        /// <summary>
        /// The button that controls transformation selection.
        /// </summary>
        public Button transformationButton
        {
            get => m_TransformationButton;
            set => m_TransformationButton = value;
        }

        delegate bool TryAcquireDepthImageDelegate(out XRCpuImage image);

        /// <summary>
        /// Cycles the image transformation to the next case.
        /// </summary>
        public void CycleTransformation()
        {
            m_Transformation = m_Transformation switch
            {
                XRCpuImage.Transformation.None => XRCpuImage.Transformation.MirrorX,
                XRCpuImage.Transformation.MirrorX => XRCpuImage.Transformation.MirrorY,
                XRCpuImage.Transformation.MirrorY => XRCpuImage.Transformation.MirrorX | XRCpuImage.Transformation.MirrorY,
                _ => XRCpuImage.Transformation.None
            };

            if (m_TransformationButton)
            {
                m_TransformationButton.GetComponentInChildren<Text>().text = m_Transformation.ToString();
            }
        }

        void OnEnable()
        {
            if (m_CameraManager == null)
            {
                Debug.LogException(new NullReferenceException(
                    $"Serialized properties were not initialized on {name}'s {nameof(CpuImageSample)} component."), this);
                return;
            }

            m_CameraManager.frameReceived += OnCameraFrameReceived;
        }

        void OnDisable()
        {
            if (m_CameraManager != null)
                m_CameraManager.frameReceived -= OnCameraFrameReceived;
        }

        void OnCameraFrameReceived(ARCameraFrameEventArgs eventArgs)
        {
            UpdateCameraImage();
            UpdateDepthImage(m_OcclusionManager.TryAcquireHumanDepthCpuImage, m_RawHumanDepthImage);
            UpdateDepthImage(m_OcclusionManager.TryAcquireHumanStencilCpuImage, m_RawHumanStencilImage);
            UpdateDepthImage(m_OcclusionManager.TryAcquireEnvironmentDepthCpuImage, m_RawEnvironmentDepthImage);
            UpdateDepthImage(m_OcclusionManager.TryAcquireEnvironmentDepthConfidenceCpuImage, m_RawEnvironmentDepthConfidenceImage);
        }

        unsafe void UpdateCameraImage()
        {
            // Attempt to get the latest camera image. If this method succeeds,
            // it acquires a native resource that must be disposed (see below).
            if (!m_CameraManager.TryAcquireLatestCpuImage(out XRCpuImage image))
            {
                return;
            }

            // Display some information about the camera image
            m_ImageInfo.text = string.Format(
                "Image info:\n\twidth: {0}\n\theight: {1}\n\tplaneCount: {2}\n\ttimestamp: {3}\n\tformat: {4}",
                image.width, image.height, image.planeCount, image.timestamp, image.format);

            // Once we have a valid XRCpuImage, we can access the individual image "planes"
            // (the separate channels in the image). XRCpuImage.GetPlane provides
            // low-overhead access to this data. This could then be passed to a
            // computer vision algorithm. Here, we will convert the camera image
            // to an RGBA texture and draw it on the screen.

            // Choose an RGBA format.
            // See XRCpuImage.FormatSupported for a complete list of supported formats.
            const TextureFormat format = TextureFormat.RGBA32;

            if (m_CameraTexture == null || m_CameraTexture.width != image.width || m_CameraTexture.height != image.height)
                m_CameraTexture = new Texture2D(image.width, image.height, format, false);

            // Convert the image to format, flipping the image across the Y axis.
            // We can also get a sub rectangle, but we'll get the full image here.
            var conversionParams = new XRCpuImage.ConversionParams(image, format, m_Transformation);

            // Texture2D allows us write directly to the raw texture data
            // This allows us to do the conversion in-place without making any copies.
            var rawTextureData = m_CameraTexture.GetRawTextureData<byte>();
            try
            {
                image.Convert(conversionParams, new IntPtr(rawTextureData.GetUnsafePtr()), rawTextureData.Length);
            }
            finally
            {
                // We must dispose of the XRCpuImage after we're finished
                // with it to avoid leaking native resources.
                image.Dispose();
            }

            // Apply the updated texture data to our texture
            m_CameraTexture.Apply();

            // Set the RawImage's texture so we can visualize it.
            m_RawCameraImage.texture = m_CameraTexture;
        }

        /// <summary>
        /// Calls <paramref name="tryAcquireDepthImageDelegate"/> and renders the resulting depth image contents to <paramref name="rawImage"/>.
        /// </summary>
        /// <param name="tryAcquireDepthImageDelegate">The method to call to acquire a depth image.</param>
        /// <param name="rawImage">The Raw Image to use to render the depth image to the screen.</param>
        void UpdateDepthImage(TryAcquireDepthImageDelegate tryAcquireDepthImageDelegate, RawImage rawImage)
        {
            if (tryAcquireDepthImageDelegate(out XRCpuImage cpuImage))
            {
                // XRCpuImages, if successfully acquired, must be disposed.
                // You can do this with a using statement as shown below, or by calling its Dispose() method directly.
                using (cpuImage)
                {
                    UpdateRawImage(rawImage, cpuImage, m_Transformation);
                }
            }
            else
            {
                rawImage.enabled = false;
            }
        }

        static void UpdateRawImage(RawImage rawImage, XRCpuImage cpuImage, XRCpuImage.Transformation transformation)
        {
            // Get the texture associated with the UI.RawImage that we wish to display on screen.
            var texture = rawImage.texture as Texture2D;

            // If the texture hasn't yet been created, or if its dimensions have changed, (re)create the texture.
            // Note: Although texture dimensions do not normally change frame-to-frame, they can change in response to
            //    a change in the camera resolution (for camera images) or changes to the quality of the human depth
            //    and human stencil buffers.
            if (texture == null || texture.width != cpuImage.width || texture.height != cpuImage.height)
            {
                texture = new Texture2D(cpuImage.width, cpuImage.height, cpuImage.format.AsTextureFormat(), false);
                rawImage.texture = texture;
            }

            // For display, we need to mirror about the vertical access.
            var conversionParams = new XRCpuImage.ConversionParams(cpuImage, cpuImage.format.AsTextureFormat(), transformation);

            // Get the Texture2D's underlying pixel buffer.
            var rawTextureData = texture.GetRawTextureData<byte>();

            // Make sure the destination buffer is large enough to hold the converted data (they should be the same size)
            Debug.Assert(rawTextureData.Length == cpuImage.GetConvertedDataSize(conversionParams.outputDimensions, conversionParams.outputFormat),
                "The Texture2D is not the same size as the converted data.");

            // Perform the conversion.
            cpuImage.Convert(conversionParams, rawTextureData);

            // "Apply" the new pixel data to the Texture2D.
            texture.Apply();

            // Make sure it's enabled.
            rawImage.enabled = true;
        }
    }
}

================
File: Assets/Scripts/Runtime/CpuImageSample.cs.meta
================
fileFormatVersion: 2
guid: c6e58200659977344ad301e3a0f6e8d7
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/DebugInfoDisplayController.cs
================
using System;
using System.Text;
using TMPro;
using UnityEngine;

namespace UnityEngine.XR.ARFoundation
{
    public class DebugInfoDisplayController : MonoBehaviour
    {
        const float k_DebugInfoBackgroundPadding = 0.04f;

        [SerializeField, Tooltip("")]
        Canvas m_Canvas;

        [SerializeField, Tooltip("")]
        RectTransform m_BackgroundRT;

        [SerializeField, Tooltip("")]
        RectTransform m_DebugLabelOffsetRT;

        [SerializeField, Tooltip("")]
        TextMeshProUGUI m_DebugLabelTypes;
        
        [SerializeField, Tooltip("")]
        TextMeshProUGUI m_DebugLabelValues;

        [SerializeField, Tooltip("")]
        RectTransform m_Icon;

        Camera m_MainCamera;
        Transform m_MainCameraTransform;
        RectTransform m_MainCameraRT;

        StringBuilder m_TypesBuilder = new();
        StringBuilder m_ValuesBuilder = new();
        Transform m_CanvasTransform;
        float m_ColumnWidth;
        Vector2 m_CanvasSizeInWorld;
        float m_HalfCanvasHeight;

        /// <summary>
        /// Sets the canvas pivot to the center when centering the canvas at
        /// its position is required.
        /// </summary>
        public void SetCenterPivot()
        {
            m_MainCameraRT.pivot = new(0.5f, m_HalfCanvasHeight);
        }

        /// <summary>
        /// Sets the canvas pivot at the bottom when positioning the canvas
        /// offset above a position is required.
        /// </summary>
        public void SetBottomPivot()
        {
            if (m_MainCameraRT != null)
                m_MainCameraRT.pivot = new(0.5f, 0f);
        }

        /// <summary>
        /// Shows or hides the debug info. Debug info is shown by default.
        /// </summary>
        /// <param name="isOn"></param>
        public void Show(bool isOn)
        {
            m_Canvas.gameObject.SetActive(isOn);
        }

        public void SetPosition(Vector3 position)
        {
            if (m_MainCameraRT != null)
                m_CanvasTransform.position = position;
        }

        public void AppendDebugEntry(string dataType, string dataValue)
        {
            FormatDebugText(dataType, dataValue);
        }

        public void RefreshDisplayInfo()
        {
            m_DebugLabelTypes.text = m_TypesBuilder.ToString();
            m_TypesBuilder.Clear();
            m_DebugLabelValues.text = m_ValuesBuilder.ToString();
            m_ValuesBuilder.Clear();

            // update background size and position
            var debugLabelTypesSize = m_DebugLabelTypes.GetPreferredValues();
            var debugLabelValuesSize = m_DebugLabelValues.GetPreferredValues();

            m_DebugLabelTypes.GetComponent<RectTransform>().sizeDelta = debugLabelTypesSize;
            m_DebugLabelValues.GetComponent<RectTransform>().sizeDelta = debugLabelValuesSize;

            var width = debugLabelTypesSize.x + debugLabelValuesSize.x;
            var widthPlusSpacingAndPadding = width + m_ColumnWidth + k_DebugInfoBackgroundPadding;
            var height = Math.Max(debugLabelTypesSize.y, debugLabelValuesSize.y);

            m_BackgroundRT.sizeDelta = new(widthPlusSpacingAndPadding, height + m_Icon.sizeDelta.y + k_DebugInfoBackgroundPadding);

            // shift background to the left to center
            var halfWidth = width * 0.5f;
            var positionOffset = Vector2.zero;
            positionOffset.x -= debugLabelTypesSize.x - halfWidth;
            positionOffset.y = -k_DebugInfoBackgroundPadding * 0.5f;
            m_BackgroundRT.anchoredPosition = positionOffset;

            // place icon in center
            m_Icon.anchoredPosition = new(positionOffset.x, height);

            // shift the label offset to the right to center
            var anchoredPosition = new Vector2(-positionOffset.x, 0);
            m_DebugLabelOffsetRT.anchoredPosition = anchoredPosition;
        }

        void Awake()
        {
            m_MainCamera = Camera.main!;
            m_MainCameraTransform = m_MainCamera.transform;
            m_Canvas.worldCamera = m_MainCamera;
            m_BackgroundRT.sizeDelta = Vector2.zero;
            m_CanvasTransform = m_Canvas.transform;
            m_MainCameraRT = m_Canvas.GetComponent<RectTransform>();

            var debugLabelValuesRT = m_DebugLabelValues.GetComponent<RectTransform>();
            m_ColumnWidth = debugLabelValuesRT.anchoredPosition.x * 2f;
            m_HalfCanvasHeight = m_MainCameraRT.sizeDelta.y * 0.5f;

            m_DebugLabelTypes.text = string.Empty;
            m_DebugLabelValues.text = string.Empty;
        }

        void Update()
        {
            var cameraToCanvasVector = transform.position - m_MainCameraTransform.position;
            m_CanvasTransform.LookAt(transform.position + cameraToCanvasVector);
        }

        void OnDestroy()
        {
            Destroy(m_DebugLabelValues.gameObject);
        }

        void FormatDebugText(string dataType, string value)
        {
            if (m_TypesBuilder.Length != 0)
                m_TypesBuilder.AppendLine();

            m_TypesBuilder.Append($"<b>{dataType}</b>");

            if (m_ValuesBuilder.Length != 0)
                m_ValuesBuilder.AppendLine();

            m_ValuesBuilder.Append(value);
        }
    }
}

================
File: Assets/Scripts/Runtime/DebugInfoDisplayController.cs.meta
================
fileFormatVersion: 2
guid: 63cadeea7c75c49a785335b34c0bb3ce
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences:
  - m_DebugInfoBackgroundSprite: {fileID: 21300000, guid: a74096c6f840e436e95cc67c4a4f6f4d,
      type: 3}
  - m_debugInfoBackgroundMaterial: {fileID: 2100000, guid: 38c8a87692f4341ccb4f0b5e3b1816f9,
      type: 2}
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/DepthImageExporter.cs
================
using System;
using System.IO;
using System.Text;
using UnityEngine;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARFoundation.Samples;
using UnityEngine.XR.ARSubsystems;

public class DepthImageExporter : MonoBehaviour
{
    [SerializeField]
    private AROcclusionManager occlusionManager;

    [SerializeField]
    private DisplayDepthImage displayDepthImage;

    private bool isSaving = false;

    void Awake()
    {
        // Auto-assign if not set in inspector
        if (occlusionManager == null)
            occlusionManager = FindAnyObjectByType<AROcclusionManager>();

        if (occlusionManager == null)
            Debug.LogError("AROcclusionManager not found!");

        if (displayDepthImage == null)
            displayDepthImage = FindAnyObjectByType<DisplayDepthImage>();
    }

    [Serializable]
    public struct DepthFrameMetadata
    {
        public int width;
        public int height;
        public XRCpuImage.Format format;
        public double timestamp;
        public float centerPixelDepth;
        public float minDepth;
        public float maxDepth;
    }

    public async void CaptureDepthFrame()
    {
        if (isSaving)
        {
            Debug.Log("Already saving a depth frame, please wait...");
            return;
        }

        if (occlusionManager == null)
        {
            Debug.LogError("Cannot capture depth frame - AROcclusionManager is null");
            return;
        }

        try
        {
            isSaving = true;
            Debug.Log("Starting depth capture...");

            if (!occlusionManager.TryAcquireEnvironmentDepthCpuImage(out XRCpuImage image))
            {
                Debug.LogError("Failed to acquire depth image");
                return;
            }

            using (image)
            {
                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string baseFilename = Path.Combine(Application.persistentDataPath, $"depth_frame_{timestamp}");
                string rawPath = $"{baseFilename}.raw";
                string metaPath = $"{baseFilename}.meta";

                Debug.Log($"Preparing to save depth data to: {rawPath}");

                // Ensure directory exists
                string directory = Path.GetDirectoryName(rawPath);
                if (!Directory.Exists(directory))
                {
                    Directory.CreateDirectory(directory);
                }

                try
                {
                    // Save raw depth data
                    SaveDepthData(image, rawPath);

                    // Save metadata
                    SaveMetadata(image, metaPath);

                    // Wait for files to be written
                    int attempts = 0;
                    while ((!File.Exists(rawPath) || !File.Exists(metaPath)) && attempts < 10)
                    {
                        await System.Threading.Tasks.Task.Delay(100);
                        attempts++;
                    }

                    if (!File.Exists(rawPath))
                    {
                        Debug.LogError($"Depth raw file was not created: {rawPath}");
                    }
                    if (!File.Exists(metaPath))
                    {
                        Debug.LogError($"Depth meta file was not created: {metaPath}");
                    }

                    Debug.Log($"Successfully saved depth frame to: {rawPath}");
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error saving depth data: {e.Message}\nStack trace: {e.StackTrace}");
                    throw;
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Error in depth capture: {e.Message}\nStack trace: {e.StackTrace}");
        }
        finally
        {
            isSaving = false;
        }
    }

    private void SaveDepthData(XRCpuImage image, string filename)
    {
        var plane = image.GetPlane(0);
        Debug.Log($"Saving depth data with size: {plane.data.Length} bytes");

        using (FileStream fs = new FileStream(filename, FileMode.Create))
        using (BinaryWriter writer = new BinaryWriter(fs))
        {
            byte[] buffer = new byte[plane.data.Length];
            plane.data.CopyTo(buffer);
            writer.Write(buffer);
        }

        Debug.Log($"Depth data saved to: {filename}");
    }

    private void SaveMetadata(XRCpuImage image, string filename)
    {
        try
        {
            var plane = image.GetPlane(0);
            var dataLength = plane.data.Length;
            var pixelStride = plane.pixelStride;
            var rowStride = plane.rowStride;

            // Calculate center pixel depth
            var centerRowIndex = dataLength / rowStride / 2;
            var centerPixelIndex = rowStride / pixelStride / 2;
            var centerPixelData = plane.data.GetSubArray(centerRowIndex * rowStride + centerPixelIndex * pixelStride, pixelStride);
            float centerDepth = displayDepthImage != null ?
                displayDepthImage.convertPixelDataToDistanceInMeters(centerPixelData.ToArray(), image.format) : 0;

            // Calculate min/max depths
            float minDepth = float.MaxValue;
            float maxDepth = float.MinValue;
            var gridDepths = CalculateGridDepths(image, plane, ref minDepth, ref maxDepth);

            var metadata = new DepthFrameMetadata
            {
                width = image.width,
                height = image.height,
                format = image.format,
                timestamp = image.timestamp,
                centerPixelDepth = centerDepth,
                minDepth = minDepth,
                maxDepth = maxDepth
            };

            string jsonMetadata = JsonUtility.ToJson(metadata, true);
            File.WriteAllText(filename, jsonMetadata);
            Debug.Log($"Depth metadata saved to: {filename}");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error saving depth metadata: {e.Message}");
            throw;
        }
    }

    private string CalculateGridDepths(XRCpuImage image, XRCpuImage.Plane plane, ref float minDepth, ref float maxDepth)
    {
        StringBuilder gridDepths = new StringBuilder();
        int gridSize = 5;
        int startX = (image.width / 2) - (gridSize / 2);
        int startY = (image.height / 2) - (gridSize / 2);

        for (int y = 0; y < gridSize; y++)
        {
            for (int x = 0; x < gridSize; x++)
            {
                int index = (startY + y) * plane.rowStride + (startX + x) * plane.pixelStride;
                var pixelData = plane.data.GetSubArray(index, plane.pixelStride).ToArray();
                float depth = displayDepthImage != null ?
                    displayDepthImage.convertPixelDataToDistanceInMeters(pixelData, image.format) : 0;

                gridDepths.Append($"{depth:F3}");
                if (x < gridSize - 1) gridDepths.Append(" ");

                if (depth > 0)
                {
                    minDepth = Mathf.Min(minDepth, depth);
                    maxDepth = Mathf.Max(maxDepth, depth);
                }
            }
            if (y < gridSize - 1) gridDepths.AppendLine();
        }

        return gridDepths.ToString();
    }
}

================
File: Assets/Scripts/Runtime/DepthImageExporter.cs.meta
================
fileFormatVersion: 2
guid: 2447ceb72463bc649bbd726041faabbb

================
File: Assets/Scripts/Runtime/DisplayDepthImage.cs
================
using System;
using System.Collections;
using System.Text;
using UnityEngine.Assertions;
using UnityEngine.UI;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// This component displays a picture-in-picture view of the environment depth texture, the human depth texture, or
    /// the human stencil texture.
    /// </summary>
    public class DisplayDepthImage : MonoBehaviour
    {
        /// <summary>
        /// The display mode for the texture widget. Values must match the UI dropdown.
        /// </summary>
        enum DisplayMode
        {
            EnvironmentDepthRaw = 0,
            EnvironmentDepthSmooth = 1,
            HumanDepth = 2,
            HumanStencil = 3,
        }

        /// <summary>
        /// Name of the max distance property in the shader.
        /// </summary>
        const string k_MaxDistanceName = "_MaxDistance";

        /// <summary>
        /// Name of the display rotation matrix in the shader.
        /// </summary>
        const string k_DisplayRotationPerFrameName = "_DisplayRotationPerFrame";

        /// <summary>
        /// The default texture aspect ratio.
        /// </summary>
        const float k_DefaultTextureAspectRadio = 1.0f;

        /// <summary>
        /// ID of the max distance  property in the shader.
        /// </summary>
        static readonly int k_MaxDistanceId = Shader.PropertyToID(k_MaxDistanceName);

        /// <summary>
        /// ID of the display rotation matrix in the shader.
        /// </summary>
        static readonly int k_DisplayRotationPerFrameId = Shader.PropertyToID(k_DisplayRotationPerFrameName);

        /// <summary>
        /// A string builder for construction of strings.
        /// </summary>
        readonly StringBuilder m_StringBuilder = new StringBuilder();

        /// <summary>
        /// The current screen orientation remembered so that we are only updating the raw image layout when it changes.
        /// </summary>
        ScreenOrientation m_CurrentScreenOrientation;

        /// <summary>
        /// The current texture aspect ratio remembered so that we can resize the raw image layout when it changes.
        /// </summary>
        float m_TextureAspectRatio = k_DefaultTextureAspectRadio;

        /// <summary>
        /// The mode indicating which texture to display.
        /// </summary>
        DisplayMode m_DisplayMode = DisplayMode.EnvironmentDepthSmooth;

        /// <summary>
        /// The display rotation matrix for the shader.
        /// </summary.
        Matrix4x4 m_DisplayRotationMatrix = Matrix4x4.identity;

#if UNITY_ANDROID
        /// <summary>
        /// A matrix to flip the Y coordinate for the Android platform.
        /// </summary>
        Matrix4x4 k_AndroidFlipYMatrix = Matrix4x4.identity;
#endif // UNITY_ANDROID

        /// <summary>
        /// Get or set the <c>AROcclusionManager</c>.
        /// </summary>
        public AROcclusionManager occlusionManager
        {
            get => m_OcclusionManager;
            set => m_OcclusionManager = value;
        }

        [SerializeField]
        [Tooltip("The AROcclusionManager which will produce depth textures.")]
        AROcclusionManager m_OcclusionManager;

        /// <summary>
        /// Get or set the <c>ARCameraManager</c>.
        /// </summary>
        public ARCameraManager cameraManager
        {
            get => m_CameraManager;
            set => m_CameraManager = value;
        }

        [SerializeField]
        [Tooltip("The ARCameraManager which will produce camera frame events.")]
        ARCameraManager m_CameraManager;

        /// <summary>
        /// The UI RawImage used to display the image on screen.
        /// </summary>
        public RawImage rawImage
        {
            get => m_RawImage;
            set => m_RawImage = value;
        }

        [SerializeField]
        RawImage m_RawImage;

        /// <summary>
        /// The UI Text used to display information about the image on screen.
        /// </summary>
        public Text imageInfo
        {
            get => m_ImageInfo;
            set => m_ImageInfo = value;
        }

        [SerializeField]
        Text m_ImageInfo;

        /// <summary>
        /// The depth material for rendering depth textures.
        /// </summary>
        public Material depthMaterial
        {
            get => m_DepthMaterial;
            set => m_DepthMaterial = value;
        }

        [SerializeField]
        Material m_DepthMaterial;

        /// <summary>
        /// The stencil material for rendering stencil textures.
        /// </summary>
        public Material stencilMaterial
        {
            get => m_StencilMaterial;
            set => m_StencilMaterial = value;
        }

        [SerializeField]
        Material m_StencilMaterial;

        /// <summary>
        /// The max distance value for the shader when showing an environment depth texture.
        /// </summary>
        public float maxEnvironmentDistance
        {
            get => m_MaxEnvironmentDistance;
            set => m_MaxEnvironmentDistance = value;
        }

        [SerializeField]
        float m_MaxEnvironmentDistance = 8.0f;

        /// <summary>
        /// The max distance value for the shader when showing an human depth texture.
        /// </summary>
        public float maxHumanDistance
        {
            get => m_MaxHumanDistance;
            set => m_MaxHumanDistance = value;
        }

        public float DepthDistance
        {
            get => depthDistance;
            set => depthDistance = value;
        }

        public float DepthDistanceCentimeters
        {
            get => depthDistance * 100f; // Convert meters to centimeters
        }

        float depthDistance = 0;

        [SerializeField]
        float m_MaxHumanDistance = 3.0f;

        void Awake()
        {
#if UNITY_ANDROID
            k_AndroidFlipYMatrix[1, 1] = -1.0f;
            k_AndroidFlipYMatrix[2, 1] = 1.0f;
#endif // UNITY_ANDROID
        }

        void OnEnable()
        {
            // Subscribe to the camera frame received event, and initialize the display rotation matrix.
            Debug.Assert(m_CameraManager != null, "no camera manager");
            m_CameraManager.frameReceived += OnCameraFrameEventReceived;
            m_DisplayRotationMatrix = Matrix4x4.identity;

            // When enabled, get the current screen orientation, and update the raw image UI.
            m_CurrentScreenOrientation = Screen.orientation;
            UpdateRawImage();

            StartCoroutine(RetrieveDepthDistance());
        }

        void OnDisable()
        {
            // Unsubscribe from the camera frame received event, and initialize the display rotation matrix.
            m_DisplayRotationMatrix = Matrix4x4.identity;
            if (m_CameraManager != null)
                m_CameraManager.frameReceived -= OnCameraFrameEventReceived;

            StopAllCoroutines();
        }

        void Update()
        {
            // If we are on a device that does supports neither human stencil, human depth, nor environment depth,
            // display a message about unsupported functionality and return.
            Debug.Assert(m_OcclusionManager != null, "no occlusion manager");

            var descriptor = m_OcclusionManager.descriptor;
            switch (m_DisplayMode)
            {
                case DisplayMode.HumanDepth:
                case DisplayMode.HumanStencil:
                    {
                        if (descriptor != null &&
                            (descriptor.humanSegmentationDepthImageSupported == Supported.Supported ||
                            descriptor.humanSegmentationStencilImageSupported == Supported.Supported))
                        {
                            break;
                        }

                        if (descriptor != null &&
                            (descriptor.humanSegmentationStencilImageSupported == Supported.Unknown ||
                             descriptor.humanSegmentationDepthImageSupported == Supported.Unknown))
                        {
                            LogText("Determining human segmentation support...");
                        }
                        else
                        {
                            LogText("Human segmentation is not supported on this device.");
                        }

                        m_RawImage.texture = null;
                        if (!Mathf.Approximately(m_TextureAspectRatio, k_DefaultTextureAspectRadio))
                        {
                            m_TextureAspectRatio = k_DefaultTextureAspectRadio;
                            UpdateRawImage();
                        }

                        return;
                    }
                case DisplayMode.EnvironmentDepthRaw:
                case DisplayMode.EnvironmentDepthSmooth:
                default:
                    {
                        if (descriptor == null || descriptor.environmentDepthImageSupported == Supported.Unsupported)
                        {
                            LogText("Environment depth is not supported on this device.");
                        }
                        else if (descriptor.environmentDepthImageSupported == Supported.Unknown)
                        {
                            LogText("Determining environment depth support...");
                        }
                        else if (descriptor.environmentDepthImageSupported == Supported.Supported)
                        {
                            m_OcclusionManager.environmentDepthTemporalSmoothingRequested = m_DisplayMode == DisplayMode.EnvironmentDepthSmooth;
                            break;
                        }

                        m_RawImage.texture = null;
                        if (!Mathf.Approximately(m_TextureAspectRatio, k_DefaultTextureAspectRadio))
                        {
                            m_TextureAspectRatio = k_DefaultTextureAspectRadio;
                            UpdateRawImage();
                        }

                        return;
                    }
            }

            // Get all of the occlusion textures.
            Texture2D humanStencil = m_OcclusionManager.humanStencilTexture;
            Texture2D humanDepth = m_OcclusionManager.humanDepthTexture;
            Texture2D envDepth = m_OcclusionManager.environmentDepthTexture;

            // Display some text information about each of the textures.
            m_StringBuilder.Clear();
            BuildTextureInfo(m_StringBuilder, "stencil", humanStencil);
            BuildTextureInfo(m_StringBuilder, "depth", humanDepth);
            BuildTextureInfo(m_StringBuilder, "env", envDepth);
            RetrieveDepthDistance();

            LogText(m_StringBuilder.ToString());

            // Decide which to display based on the current mode.
            Texture2D displayTexture;
            switch (m_DisplayMode)
            {
                case DisplayMode.HumanStencil:
                    displayTexture = humanStencil;
                    break;
                case DisplayMode.HumanDepth:
                    displayTexture = humanDepth;
                    break;
                case DisplayMode.EnvironmentDepthRaw:
                case DisplayMode.EnvironmentDepthSmooth:
                default:
                    displayTexture = envDepth;
                    break;
            }

            // Assign the texture to display to the raw image.
            Debug.Assert(m_RawImage != null, "no raw image");
            m_RawImage.texture = displayTexture;

            // Get the aspect ratio for the current texture.
            float textureAspectRatio = (displayTexture == null) ? 1.0f : ((float)displayTexture.width / (float)displayTexture.height);

            // If the raw image needs to be updated because of a device orientation change or because of a texture
            // aspect ratio difference, then update the raw image with the new values.
            if ((m_CurrentScreenOrientation != Screen.orientation)
                || !Mathf.Approximately(m_TextureAspectRatio, textureAspectRatio))
            {
                m_CurrentScreenOrientation = Screen.orientation;
                m_TextureAspectRatio = textureAspectRatio;
                UpdateRawImage();
            }
        }

        /// <summary>
        /// When the camera frame event is raised, capture the display rotation matrix.
        /// </summary>
        /// <param name="cameraFrameEventArgs">The arguments when a camera frame event is raised.</param>
        void OnCameraFrameEventReceived(ARCameraFrameEventArgs cameraFrameEventArgs)
        {
            Debug.Assert(m_RawImage != null, "no raw image");
            if (m_RawImage.material != null)
            {
                // Copy the display rotation matrix from the camera.
                Matrix4x4 cameraMatrix = cameraFrameEventArgs.displayMatrix ?? Matrix4x4.identity;

                // The camera display matrix includes scaling and offsets to fit the aspect ratio of the device. In most
                // cases, the camera display matrix should be used directly without modification when applying depth to
                // the scene because that will line up the depth image with the camera image. However, for this demo,
                // we want to show the full depth image as a picture-in-picture, so we remove these scaling and offset
                // factors while preserving the orientation.
                Vector2 affineBasisX = new Vector2(cameraMatrix[0, 0], cameraMatrix[1, 0]);
                Vector2 affineBasisY = new Vector2(cameraMatrix[0, 1], cameraMatrix[1, 1]);
                Vector2 affineTranslation = new Vector2(cameraMatrix[2, 0], cameraMatrix[2, 1]);
                affineBasisX = affineBasisX.normalized;
                affineBasisY = affineBasisY.normalized;
                m_DisplayRotationMatrix = Matrix4x4.identity;
                m_DisplayRotationMatrix[0, 0] = affineBasisX.x;
                m_DisplayRotationMatrix[0, 1] = affineBasisY.x;
                m_DisplayRotationMatrix[1, 0] = affineBasisX.y;
                m_DisplayRotationMatrix[1, 1] = affineBasisY.y;
                m_DisplayRotationMatrix[2, 0] = Mathf.Round(affineTranslation.x);
                m_DisplayRotationMatrix[2, 1] = Mathf.Round(affineTranslation.y);

                // Set the matrix to the raw image material.
                m_RawImage.material.SetMatrix(k_DisplayRotationPerFrameId, m_DisplayRotationMatrix);
            }
        }

        /// <summary>
        /// Create log information about the given texture.
        /// </summary>
        /// <param name="stringBuilder">The string builder to which to append the texture information.</param>
        /// <param name="textureName">The semantic name of the texture for logging purposes.</param>
        /// <param name="texture">The texture for which to log information.</param>
        void BuildTextureInfo(StringBuilder stringBuilder, string textureName, Texture2D texture)
        {
            stringBuilder.AppendLine($"texture : {textureName}");
            if (texture == null)
            {
                stringBuilder.AppendLine("   <null>");
            }
            else
            {
                stringBuilder.AppendLine($"   format : {texture.format}");
                stringBuilder.AppendLine($"   width  : {texture.width}");
                stringBuilder.AppendLine($"   height : {texture.height}");
                stringBuilder.AppendLine($"   mipmap : {texture.mipmapCount}");
                stringBuilder.AppendLine($"   distance (meters): {DepthDistance:F2}");
                stringBuilder.AppendLine($"   distance (centimeters): {DepthDistanceCentimeters:F1}");

                // Add color mapping info
                if (texture == m_OcclusionManager.environmentDepthTexture)
                {
                    stringBuilder.AppendLine("\n" + GetDepthColorMapping());
                }
            }
        }


        IEnumerator RetrieveDepthDistance()
        {
            while (true)
            {
                try
                {
                    if (occlusionManager != null && occlusionManager.TryAcquireEnvironmentDepthCpuImage(out var cpuImage))
                    {
                        using (cpuImage)
                        {
                            if (cpuImage.valid)
                            {
                                Assert.IsTrue(cpuImage.planeCount == 1);
                                var plane = cpuImage.GetPlane(0);
                                var dataLength = plane.data.Length;
                                var pixelStride = plane.pixelStride;
                                var rowStride = plane.rowStride;

                                var centerRowIndex = dataLength / rowStride / 2;
                                var centerPixelIndex = rowStride / pixelStride / 2;
                                var centerPixelData = plane.data.GetSubArray(centerRowIndex * rowStride + centerPixelIndex * pixelStride, pixelStride);
                                DepthDistance = convertPixelDataToDistanceInMeters(centerPixelData.ToArray(), cpuImage.format);

                                // Calculate normalized depth value (0 to 1)
                                float normalizedDepth = Mathf.Clamp01(DepthDistance / m_MaxEnvironmentDistance);

                                // Determine color range (reversed from before)
                                // string colorRange = "Unknown";
                                // if (normalizedDepth < 0.2f) colorRange = "Blue (Closest)";
                                // else if (normalizedDepth < 0.4f) colorRange = "Cyan";
                                // else if (normalizedDepth < 0.6f) colorRange = "Green";
                                // else if (normalizedDepth < 0.8f) colorRange = "Yellow";
                                // else colorRange = "Red (Farthest)";

                                // Debug.Log($"Depth: {DepthDistance:F2}m ({DepthDistanceCentimeters:F1}cm)" +
                                //         $"\nNormalized depth: {normalizedDepth:F2}" +
                                //         $"\nColor range: {colorRange}" +
                                //         $"\nPercentage of max: {(normalizedDepth * 100):F1}%");
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error retrieving depth: {e.Message}");
                }

                yield return new WaitForSeconds(0.1f);
            }
        }
        /// <summary>
        /// Log the given text to the screen if the image info UI is set. Otherwise, log the string to debug.
        /// </summary>
        /// <param name="text">The text string to log.</param>
        void LogText(string text)
        {
            if (m_ImageInfo != null)
            {
                m_ImageInfo.text = text;
            }
            else
            {
                Debug.Log(text);
            }
        }

        /// <summary>
        /// Update the raw image with the current configurations.
        /// </summary>
        void UpdateRawImage()
        {
            Debug.Assert(m_RawImage != null, "no raw image");

            // Determine the raw imge rectSize preserving the texture aspect ratio, matching the screen orientation,
            // and keeping a minimum dimension size.
            float minDimension = 480.0f;
            float maxDimension = Mathf.Round(minDimension * m_TextureAspectRatio);
            if (minDimension > maxDimension)
            {
                (minDimension, maxDimension) = (maxDimension, minDimension);
            }
            Vector2 rectSize;
            switch (m_CurrentScreenOrientation)
            {
                case ScreenOrientation.LandscapeRight:
                case ScreenOrientation.LandscapeLeft:
                    rectSize = new Vector2(maxDimension, minDimension);
                    break;
                case ScreenOrientation.PortraitUpsideDown:
                case ScreenOrientation.Portrait:
                default:
                    rectSize = new Vector2(minDimension, maxDimension);
                    break;
            }

            // Determine the raw image material and maxDistance material parameter based on the display mode.
            float maxDistance;
            Material material;
            switch (m_DisplayMode)
            {
                case DisplayMode.HumanStencil:
                    material = m_StencilMaterial;
                    maxDistance = m_MaxHumanDistance;
                    break;
                case DisplayMode.HumanDepth:
                    material = m_DepthMaterial;
                    maxDistance = m_MaxHumanDistance;
                    break;
                case DisplayMode.EnvironmentDepthRaw:
                case DisplayMode.EnvironmentDepthSmooth:
                default:
                    material = m_DepthMaterial;
                    maxDistance = m_MaxEnvironmentDistance;
                    break;
            }

            // Update the raw image dimensions and the raw image material parameters.
            m_RawImage.rectTransform.sizeDelta = rectSize;
            material.SetFloat(k_MaxDistanceId, maxDistance);
            material.SetMatrix(k_DisplayRotationPerFrameId, m_DisplayRotationMatrix);
            m_RawImage.material = material;
        }

        /// <summary>
        /// Callback when the depth mode dropdown UI has a value change.
        /// </summary>
        /// <param name="dropdown">The dropdown UI that changed.</param>
        public void OnDepthModeDropdownValueChanged(Dropdown dropdown)
        {
            // Update the display mode from the dropdown value.
            m_DisplayMode = (DisplayMode)dropdown.value;

            // Update the raw image following the mode change.
            UpdateRawImage();
        }

        public float convertPixelDataToDistanceInMeters(byte[] data, XRCpuImage.Format format)
        {
            switch (format)
            {
                case XRCpuImage.Format.DepthUint16:
                    return BitConverter.ToUInt16(data, 0) / 1000f;
                case XRCpuImage.Format.DepthFloat32:
                    return BitConverter.ToSingle(data, 0);
                default:
                    throw new Exception($"Format not supported: {format}");
            }
        }

        // Add this method to your DisplayDepthImage class to get color mapping for depth values
        private string GetDepthColorMapping()
        {
            float maxDist = m_MaxEnvironmentDistance; // 0.7m in your case
            StringBuilder mapping = new StringBuilder();
            mapping.AppendLine("Depth Color Mapping (max distance = 0.7m):");
            mapping.AppendLine("Blue   -> 0.0m to 0.14m (closest)");
            mapping.AppendLine("Cyan   -> 0.14m to 0.28m");
            mapping.AppendLine("Green  -> 0.28m to 0.42m");
            mapping.AppendLine("Yellow -> 0.42m to 0.56m");
            mapping.AppendLine("Red    -> 0.56m to 0.7m (farthest)");

            return mapping.ToString();
        }

    }
}

================
File: Assets/Scripts/Runtime/DisplayDepthImage.cs.meta
================
fileFormatVersion: 2
guid: 5b552aa0564624c56ae746579bc814e6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Logger.cs
================
using System;
using System.Collections.Generic;
using System.Text;
using TMPro;
using UnityEngine;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class Logger : MonoBehaviour
    {
        [SerializeField]
        TextMeshProUGUI m_LogText;
        public TextMeshProUGUI logText
        {
            get => m_LogText;
            set => m_LogText = value;
        }

        [SerializeField]
        int m_VisibleMessageCount = 40;
        public int visibleMessageCount
        {
            get => m_VisibleMessageCount;
            set => m_VisibleMessageCount = value;
        }

        int m_LastMessageCount;

        static List<string> s_Log = new List<string>();

        static StringBuilder m_StringBuilder = new StringBuilder();

        void Awake()
        {
            if (m_LogText == null)
            {
                m_LogText = GetComponent<TextMeshProUGUI>();
            }

            lock (s_Log)
            {
                s_Log?.Clear();
            }

            Log("Log console initialized.");
        }

        void Update()
        {
            lock (s_Log)
            {
                if (m_LastMessageCount != s_Log.Count)
                {
                    m_StringBuilder.Clear();
                    var startIndex = Mathf.Max(s_Log.Count - m_VisibleMessageCount, 0);
                    for (int i = startIndex; i < s_Log.Count; ++i)
                    {
                        m_StringBuilder.Append($"{i:000}> {s_Log[i]}\n");
                    }

                    var text = m_StringBuilder.ToString();

                    if (m_LogText)
                    {
                        m_LogText.text = text;
                    }
                    else
                    {
                        Debug.Log(text);
                    }
                }

                m_LastMessageCount = s_Log.Count;
            }
        }

        public static void Log(string message)
        {
            lock (s_Log)
            {
                if (s_Log == null)
                    s_Log = new List<string>();

                s_Log.Add(message);
            }
        }
    }
}

================
File: Assets/Scripts/Runtime/Logger.cs.meta
================
fileFormatVersion: 2
guid: 6b9ec441ecd1d4c21b5736659749bcf2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Models.cs
================
namespace UnityEngine.XR.ARFoundation.Samples.Assets.Scripts.Runtime
{
    using System;
    using System.Collections.Generic;
    using UnityEngine;

    [Serializable]
    public class NutritionApiResponse
    {
        public ResponseData data;
        public MacronutrientsData macronutrients;
        public bool success;
    }

    [Serializable]
    public class ResponseData
    {
        public string frame_id;
        public List<VolumeData> volumes;
    }

    [Serializable]
    public class VolumeData
    {
        public string object_name;
        public float uncertainty_cups;
        public float volume_cups;
    }

    [Serializable]
    public class MacronutrientsData
    {
        public List<FoodMacroData> data;
    }

    [Serializable]
    public class FoodMacroData
    {
        public string ServingInfo;
        public bool found;
        public MacroNutrients macros;
        public string requested_food;
        public float volume;
        public float calculated_weight;
    }

    [Serializable]
    public class MacroNutrients
    {
        public float calories;
        public float carbs;
        public float fat;
        public float protein;
    }

    // Display-friendly data structure
    [Serializable]
    public class FoodNutritionInfo
    {
        public string foodName;
        public float fat;
        public float protein;
        public float calories;
        public float carbohydrates;
        public float estimatedVolume;
        public string volumeUnit = "cups";
        public float calculatedWeight;
        public string weightUnit = "g";

        public static FoodNutritionInfo FromApiData(ResponseData responseData, FoodMacroData macroData)
        {
            // Find matching volume data
            var volumeData = responseData.volumes.Find(v => v.object_name == macroData.requested_food);

            // Parse weight from ServingInfo
            return new FoodNutritionInfo
            {
                foodName = macroData.requested_food,
                fat = macroData.macros.fat,
                calories = macroData.macros.calories,
                protein = macroData.macros.protein,
                carbohydrates = macroData.macros.carbs,
                estimatedVolume = volumeData.volume_cups,
                calculatedWeight = macroData.calculated_weight
            };
        }
    }

    // Test data generator
    public static class NutritionTestData
    {
        public static NutritionApiResponse CreateDummyResponse()
        {
            return new NutritionApiResponse
            {
                data = new ResponseData
                {
                    frame_id = "130043.51440302501",
                    volumes = new List<VolumeData>
                {
                    new VolumeData
                    {
                        object_name = "egg",
                        uncertainty_cups = 0.0410032146343626f,
                        volume_cups = 0.41003214634362595f,
                    },
                    new VolumeData
                    {
                        object_name = "rice",
                        uncertainty_cups = 0.13725909535326242f,
                        volume_cups = 1.3725909535326242f
                    }
                }
                },
                macronutrients = new MacronutrientsData
                {
                    data = new List<FoodMacroData>
                {
                    new FoodMacroData
                    {
                        found = true,
                        macros = new MacroNutrients
                        {
                            calories = 596.66046f,
                            carbs = 2.2825572f,
                            fat = 42.683823f,
                            protein = 46.6783f
                        },
                        calculated_weight = 100,
                        requested_food = "egg",
                        volume = 0.41003215f
                    },
                    new FoodMacroData
                    {
                        found = true,
                        macros = new MacroNutrients
                        {
                            calories = 461.09473f,
                            carbs = 85.35013f,
                            fat = 8.330989f,
                            protein = 11.391352f
                        },
                        calculated_weight = 160,
                        requested_food = "rice",
                        volume = 1.3725909f
                    }
                }
                },
                success = true
            };
        }

        // Example usage of test data:
        public static void PrintTestData()
        {
            var response = CreateDummyResponse();
            foreach (var foodData in response.macronutrients.data)
            {
                var displayInfo = FoodNutritionInfo.FromApiData(response.data, foodData);
                Debug.Log($"Food: {displayInfo.foodName}\n" +
                         $"Volume: {displayInfo.estimatedVolume} {displayInfo.volumeUnit}\n" +
                         $"Weight: {displayInfo.calculatedWeight} {displayInfo.weightUnit}\n" +
                         $"Macros (g) - Protein: {displayInfo.protein}, Fat: {displayInfo.fat}, Carbs: {displayInfo.carbohydrates}");
            }
        }
    }
}

================
File: Assets/Scripts/Runtime/Models.cs.meta
================
fileFormatVersion: 2
guid: a8b5a24a58dfcbd428f35c6e1d7fef82

================
File: Assets/Scripts/Runtime/Multipeer.meta
================
fileFormatVersion: 2
guid: ab5ca8171efd6403fa3e0f422eccde1e
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/MCSession.cs
================
using System;
using System.Runtime.InteropServices;

namespace Unity.iOS.Multipeer
{
    [StructLayout(LayoutKind.Sequential)]
    public struct MCSession : IDisposable, IEquatable<MCSession>
    {
        IntPtr m_Ptr;

        public bool Created => m_Ptr != IntPtr.Zero;

        public bool Enabled
        {
            get
            {
                if (!Created)
                    return false;
                return GetEnabled(this);
            }

            set
            {
                if (!Created && value)
                    throw new InvalidOperationException();
                SetEnabled(this, value);
            }
        }

        public MCSession(string peerName, string serviceType)
        {
            if (peerName == null)
                throw new ArgumentNullException(nameof(peerName));

            if (serviceType == null)
                throw new ArgumentNullException(nameof(serviceType));

            using (var peerName_NSString = new NSString(peerName))
            using (var serviceType_NSString = new NSString(serviceType))
            {
                m_Ptr = InitWithName(peerName_NSString, serviceType_NSString);
            }
        }

        public void SendToAllPeers(NSData data, MCSessionSendDataMode mode)
        {
            if (!Created)
                throw new InvalidOperationException($"The {typeof(MCSession).Name} has not been created.");

            if (!data.Created)
                throw new ArgumentException($"'{nameof(data)}' is not valid.", nameof(data));

            using (var error = SendToAllPeers(this, data, mode))
            {
                if (error.Valid)
                    throw error.ToException();
            }
        }

        public int ReceivedDataQueueSize => GetReceivedDataQueueSize(this);

        public NSData DequeueReceivedData()
        {
            if (!Created)
                throw new InvalidOperationException($"The {typeof(MCSession).Name} has not been created.");

            return DequeueReceivedData(this);
        }

        public int ConnectedPeerCount => GetConnectedPeerCount(this);

        public void Dispose() => NativeApi.CFRelease(ref m_Ptr);
        public override int GetHashCode() => m_Ptr.GetHashCode();
        public override bool Equals(object obj) => (obj is MCSession) && Equals((MCSession)obj);
        public bool Equals(MCSession other) => m_Ptr == other.m_Ptr;
        public static bool operator==(MCSession lhs, MCSession rhs) => lhs.Equals(rhs);
        public static bool operator!=(MCSession lhs, MCSession rhs) => !lhs.Equals(rhs);

        [DllImport("__Internal", EntryPoint="UnityMC_Delegate_sendToAllPeers")]
        static extern NSError SendToAllPeers(MCSession self, NSData data, MCSessionSendDataMode mode);

        [DllImport("__Internal", EntryPoint="UnityMC_Delegate_initWithName")]
        static extern IntPtr InitWithName(NSString name, NSString serviceType);

        [DllImport("__Internal", EntryPoint="UnityMC_Delegate_receivedDataQueueSize")]
        static extern int GetReceivedDataQueueSize(MCSession self);

        [DllImport("__Internal", EntryPoint="UnityMC_Delegate_dequeueReceivedData")]
        static extern NSData DequeueReceivedData(MCSession self);

        [DllImport("__Internal", EntryPoint="UnityMC_Delegate_connectedPeerCount")]
        static extern int GetConnectedPeerCount(MCSession self);

        [DllImport("__Internal", EntryPoint="UnityMC_Delegate_setEnabled")]
        static extern void SetEnabled(MCSession self, bool enabled);

        [DllImport("__Internal", EntryPoint="UnityMC_Delegate_getEnabled")]
        static extern bool GetEnabled(MCSession self);
    }
}

================
File: Assets/Scripts/Runtime/Multipeer/MCSession.cs.meta
================
fileFormatVersion: 2
guid: f0dd3cf9695cb42f7b9ffa20d3a59011
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/MCSessionSendDataMode.cs
================
namespace Unity.iOS.Multipeer
{
    /// <summary>
    /// MCSession send modes
    /// </summary>
    public enum MCSessionSendDataMode
    {
        /// <summary>
        /// Guaranteed reliable and in-order delivery.
        /// </summary>
        Reliable,

        /// <summary>
        /// Sent immediately without queuing, no guaranteed delivery.
        /// </summary>
        Unreliable
    }
}

================
File: Assets/Scripts/Runtime/Multipeer/MCSessionSendDataMode.cs.meta
================
fileFormatVersion: 2
guid: 5673d45a5dae34743841658416feef52
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NativeApi.cs
================
using System;
using System.Runtime.InteropServices;

namespace Unity.iOS.Multipeer
{
    internal static class NativeApi
    {
        public static void CFRelease(ref IntPtr ptr)
        {
            CFRelease(ptr);
            ptr = IntPtr.Zero;
        }

        [DllImport("__Internal", EntryPoint="UnityMC_CFRelease")]
        public static extern void CFRelease(IntPtr ptr);
    }
}

================
File: Assets/Scripts/Runtime/Multipeer/NativeApi.cs.meta
================
fileFormatVersion: 2
guid: 06e6b03cb95994416a492630b1c74fd0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode.meta
================
fileFormatVersion: 2
guid: 841a08ffbdce6452182dcbfc65a3054c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate-C-Bridge.m
================
#include "MultipeerDelegate.h"

typedef void* ManagedMultipeerDelegate;
typedef void* ManagedNSError;

ManagedMultipeerDelegate UnityMC_Delegate_initWithName(void* name, void* serviceType)
{
    MultipeerDelegate* delegate = [[MultipeerDelegate alloc] initWithName:(__bridge NSString*)name
                                                              serviceType:(__bridge NSString*)serviceType];
    return (__bridge_retained void*)delegate;
}

ManagedNSError UnityMC_Delegate_sendToAllPeers(void* self, void* nsdata, int length, int mode)
{
    NSData* data = (__bridge NSData*)nsdata;
    MultipeerDelegate* delegate = (__bridge MultipeerDelegate*)self;
    NSError* error = [delegate sendToAllPeers:data withMode:(MCSessionSendDataMode)mode];
    return (__bridge_retained void*)error;
}

int UnityMC_Delegate_receivedDataQueueSize(void* self)
{
    if (self == NULL)
        return 0;

    MultipeerDelegate* delegate = (__bridge MultipeerDelegate*)self;
    return (int)delegate.queueSize;
}

void* UnityMC_Delegate_dequeueReceivedData(void* self)
{
    MultipeerDelegate* delegate = (__bridge MultipeerDelegate*)self;
    return (__bridge_retained void*)delegate.dequeue;
}

int UnityMC_Delegate_connectedPeerCount(void* self)
{
    MultipeerDelegate* delegate = (__bridge MultipeerDelegate*)self;
    return (int)delegate.connectedPeerCount;
}

void UnityMC_Delegate_setEnabled(void* self, bool enabled)
{
    MultipeerDelegate* delegate = (__bridge MultipeerDelegate*)self;
    delegate.enabled = enabled;
}

bool UnityMC_Delegate_getEnabled(void* self)
{
    MultipeerDelegate* delegate = (__bridge MultipeerDelegate*)self;
    return delegate.enabled;
}

void UnityMC_CFRelease(void* ptr)
{
    if (ptr)
    {
        CFRelease(ptr);
    }
}

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate-C-Bridge.m.meta
================
fileFormatVersion: 2
guid: f94297f07eee14b96b55b6ed49779df0
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 0
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      iPhone: iOS
    second:
      enabled: 1
      settings:
        FrameworkDependencies: MultipeerConnectivity;
  - first:
      tvOS: tvOS
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate.h
================
#import <MultipeerConnectivity/MultipeerConnectivity.h>

@interface MultipeerDelegate : NSObject<MCSessionDelegate, MCNearbyServiceAdvertiserDelegate, MCNearbyServiceBrowserDelegate>

- (nullable instancetype)initWithName:(nonnull NSString *)name serviceType:(nonnull NSString*)serviceType;
- (nullable NSError*)sendToAllPeers:(nonnull NSData*)data withMode:(MCSessionSendDataMode)mode;
- (NSUInteger)connectedPeerCount;
- (NSUInteger)queueSize;
- (nonnull NSData*)dequeue;

@property BOOL enabled;

@end

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate.h.meta
================
fileFormatVersion: 2
guid: 598b4c4bd189e49b4b17a87ba0cf5418
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 1
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate.m
================
#import "MultipeerDelegate.h"

@implementation MultipeerDelegate

MCSession* m_Session;
MCPeerID* m_PeerID;
NSMutableArray* m_Queue;
MCNearbyServiceAdvertiser* m_ServiceAdvertiser;
MCNearbyServiceBrowser* m_ServiceBrowser;
BOOL m_Enabled;

- (instancetype)initWithName:(nonnull NSString *)name serviceType:(nonnull NSString *)serviceType
{
    if (self = [super init])
    {
        m_Enabled = false;
        m_Queue = [[NSMutableArray alloc] init];
        m_PeerID = [[MCPeerID alloc] initWithDisplayName: name];
        m_Session = [[MCSession alloc] initWithPeer:m_PeerID
                                   securityIdentity:nil
                               encryptionPreference:MCEncryptionRequired];
        m_Session.delegate = self;

        m_ServiceAdvertiser = [[MCNearbyServiceAdvertiser alloc] initWithPeer:m_PeerID
                                                                discoveryInfo:nil
                                                                  serviceType:serviceType];
        m_ServiceAdvertiser.delegate = self;

        m_ServiceBrowser = [[MCNearbyServiceBrowser alloc] initWithPeer:m_PeerID
                                                            serviceType:serviceType];
        m_ServiceBrowser.delegate = self;
    }

    return self;
}

- (BOOL)enabled
{
    return m_Enabled;
}

- (void)setEnabled:(BOOL)enabled
{
    if (enabled)
    {
        [m_ServiceAdvertiser startAdvertisingPeer];
        [m_ServiceBrowser startBrowsingForPeers];
    }
    else
    {
        [m_ServiceAdvertiser stopAdvertisingPeer];
        [m_ServiceBrowser stopBrowsingForPeers];
        @synchronized (m_Queue)
        {
            [m_Queue removeAllObjects];
        }
    }

    m_Enabled = enabled;
}

- (NSError*)sendToAllPeers:(nonnull NSData*)data withMode:(MCSessionSendDataMode)mode
{
    if (m_Session.connectedPeers.count == 0)
        return nil;

    NSError* error = nil;
    [m_Session sendData:data
                toPeers:m_Session.connectedPeers
               withMode:mode
                  error:&error];

    return error;
}

- (NSUInteger)queueSize
{
    @synchronized (m_Queue)
    {
        return m_Queue.count;
    }
}

- (nonnull NSData*)dequeue
{
    @synchronized (m_Queue)
    {
        NSData* data = [m_Queue objectAtIndex:0];
        [m_Queue removeObjectAtIndex:0];
        return data;
    }
}

- (NSUInteger)connectedPeerCount
{
    return m_Session.connectedPeers.count;
}

- (void)session:(nonnull MCSession *)session didFinishReceivingResourceWithName:(nonnull NSString *)resourceName fromPeer:(nonnull MCPeerID *)peerID atURL:(nullable NSURL *)localURL withError:(nullable NSError *)error {
    // Not used.
}

- (void)session:(nonnull MCSession *)session didReceiveData:(nonnull NSData *)data fromPeer:(nonnull MCPeerID *)peerID
{
    @synchronized (m_Queue)
    {
        [m_Queue addObject:data];
    }
}

- (void)session:(nonnull MCSession *)session didReceiveStream:(nonnull NSInputStream *)stream withName:(nonnull NSString *)streamName fromPeer:(nonnull MCPeerID *)peerID {
    // Not used.
}

- (void)session:(nonnull MCSession *)session didStartReceivingResourceWithName:(nonnull NSString *)resourceName fromPeer:(nonnull MCPeerID *)peerID withProgress:(nonnull NSProgress *)progress {
    // Not used.
}

- (void)session:(nonnull MCSession *)session peer:(nonnull MCPeerID *)peerID didChangeState:(MCSessionState)state {
    // Not used.
}

- (void)advertiser:(nonnull MCNearbyServiceAdvertiser *)advertiser didReceiveInvitationFromPeer:(nonnull MCPeerID *)peerID withContext:(nullable NSData *)context invitationHandler:(nonnull void (^)(BOOL, MCSession * _Nullable))invitationHandler
{
    invitationHandler(YES, m_Session);
}

- (void)browser:(nonnull MCNearbyServiceBrowser *)browser foundPeer:(nonnull MCPeerID *)peerID withDiscoveryInfo:(nullable NSDictionary<NSString *,NSString *> *)info
{
    // Invite the peer to join our session
    [browser invitePeer:peerID
              toSession:m_Session
            withContext:nil
                timeout:10];
}

- (void)browser:(nonnull MCNearbyServiceBrowser *)browser lostPeer:(nonnull MCPeerID *)peerID
{
    // Not used
}

@end

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/MultipeerDelegate.m.meta
================
fileFormatVersion: 2
guid: cba1a95445f3e40ac8bbf00450e84734
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      '': Any
    second:
      enabled: 0
      settings:
        Exclude Android: 1
        Exclude Editor: 1
        Exclude Linux: 1
        Exclude Linux64: 1
        Exclude LinuxUniversal: 1
        Exclude Lumin: 1
        Exclude OSXUniversal: 1
        Exclude Win: 1
        Exclude Win64: 1
        Exclude iOS: 0
  - first:
      Android: Android
    second:
      enabled: 0
      settings:
        CPU: ARMv7
  - first:
      Any: 
    second:
      enabled: 0
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
        DefaultValueInitialized: true
        OS: AnyOS
  - first:
      Facebook: Win
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Facebook: Win64
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Standalone: Linux
    second:
      enabled: 0
      settings:
        CPU: x86
  - first:
      Standalone: Linux64
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Standalone: OSXUniversal
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Standalone: Win
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      Standalone: Win64
    second:
      enabled: 0
      settings:
        CPU: AnyCPU
  - first:
      iPhone: iOS
    second:
      enabled: 1
      settings:
        AddToEmbeddedBinaries: false
        CompileFlags: 
        FrameworkDependencies: MultipeerConnectivity;
  - first:
      tvOS: tvOS
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/NSData-C-Bridge.m
================
#import <Foundation/Foundation.h>

int UnityMC_NSData_getLength(void* self)
{
    NSData* data = (__bridge NSData*)self;
    return (int)data.length;
}

void* UnityMC_NSData_createWithBytes(void* bytes, int length)
{
    NSData* data = [[NSData alloc] initWithBytes:bytes
                                          length:length];

    return (__bridge_retained void*)data;
}

void* UnityMC_NSData_createWithBytesNoCopy(void* bytes, int length, bool freeWhenDone)
{
    NSData* data = [[NSData alloc] initWithBytesNoCopy:bytes
                                                length:length
                                          freeWhenDone:freeWhenDone];

    return (__bridge_retained void*)data;
}

const void* UnityMC_NSData_getBytes(void* self)
{
    NSData* data = (__bridge NSData*)self;
    return data.bytes;
}

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/NSData-C-Bridge.m.meta
================
fileFormatVersion: 2
guid: a452ea1f1d87e4256a5af3b742f78e18
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 0
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      iPhone: iOS
    second:
      enabled: 1
      settings: {}
  - first:
      tvOS: tvOS
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/NSError-C-Bridge.m
================
#import <Foundation/Foundation.h>

long UnityMC_NSError_code(void* ptr)
{
    return ((__bridge NSError*)ptr).code;
}

void* UnityMC_NSError_localizedDescription(void* ptr)
{
    NSString* desc = ((__bridge NSError*)ptr).localizedDescription;
    return (__bridge_retained void*)desc;
}

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/NSError-C-Bridge.m.meta
================
fileFormatVersion: 2
guid: a2cf20442c9d3412f9b1978da0184a7f
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 0
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      iPhone: iOS
    second:
      enabled: 1
      settings: {}
  - first:
      tvOS: tvOS
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/NSString-C-Bridge.m
================
#import <Foundation/Foundation.h>

int UnityMC_NSString_lengthOfBytesUsingEncoding(void* self)
{
    if (self == NULL)
        return 0;

    NSString* string = (__bridge NSString*)self;
    return (int)[string lengthOfBytesUsingEncoding:NSUTF16LittleEndianStringEncoding];
}

bool UnityMC_NSString_getBytes(void* self, void* buffer, int length)
{
    NSString* string = (__bridge NSString*)self;
    const NSRange range = NSMakeRange(0, string.length);
    return [string getBytes:buffer
                  maxLength:length
                 usedLength:NULL
                   encoding:NSUTF16LittleEndianStringEncoding
                    options:0
                      range:range
             remainingRange:NULL];
}

int UnityMC_NSString_getLength(void* self)
{
    NSString* string = (__bridge NSString*)self;
    return (int)string.length;
}

void* UnityMC_NSString_createWithString(void* bytes, int length)
{
    NSString* string = [[NSString alloc] initWithBytes: bytes
                                                length: 2 * length
                                              encoding: NSUTF16LittleEndianStringEncoding];

    return (__bridge_retained void*)string;
}

void* UnityMC_NSString_serialize(void* self)
{
    NSString* string = (__bridge NSString*)self;
    NSData* data = [NSKeyedArchiver archivedDataWithRootObject:string];
    return (__bridge_retained void*)data;
}

void* UnityMC_NSString_deserialize(void* serializedString)
{
    NSData* data = (__bridge NSData*)serializedString;
    NSString* string = [NSKeyedUnarchiver unarchiveObjectWithData:data];
    return (__bridge_retained void*)string;
}

================
File: Assets/Scripts/Runtime/Multipeer/NativeCode/NSString-C-Bridge.m.meta
================
fileFormatVersion: 2
guid: f45e73c2d697643c898c3f259d718667
PluginImporter:
  externalObjects: {}
  serializedVersion: 2
  iconMap: {}
  executionOrder: {}
  defineConstraints: []
  isPreloaded: 0
  isOverridable: 0
  isExplicitlyReferenced: 0
  validateReferences: 1
  platformData:
  - first:
      Any: 
    second:
      enabled: 0
      settings: {}
  - first:
      Editor: Editor
    second:
      enabled: 0
      settings:
        DefaultValueInitialized: true
  - first:
      iPhone: iOS
    second:
      enabled: 1
      settings: {}
  - first:
      tvOS: tvOS
    second:
      enabled: 1
      settings: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NSData.cs
================
using System;
using System.Runtime.InteropServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.iOS.Multipeer
{
    [StructLayout(LayoutKind.Sequential)]
    public struct NSData : IDisposable, IEquatable<NSData>
    {
        IntPtr m_Ptr;

        internal NSData(IntPtr existing) => m_Ptr = existing;

        public bool Created => m_Ptr != IntPtr.Zero;

        public int Length => Created ? GetLength(this) : 0;

        public static unsafe NSData CreateWithBytes(NativeSlice<byte> bytes)
        {
            var ptr = bytes.GetUnsafePtr();
            if (ptr == null)
                throw new ArgumentException($"The {typeof(NativeSlice<byte>).Name} is not valid.", nameof(bytes));

            return new NSData(CreateWithBytes(ptr, bytes.Length));
        }

        public static unsafe NSData CreateWithBytesNoCopy(NativeSlice<byte> bytes)
        {
            var ptr = bytes.GetUnsafePtr();
            if (ptr == null)
                throw new ArgumentException($"The {typeof(NativeSlice<byte>).Name} is not valid.", nameof(bytes));

            return new NSData(CreateWithBytesNoCopy(ptr, bytes.Length, false));
        }

        public unsafe NativeSlice<byte> Bytes
        {
            get
            {
                if (!Created)
                    throw new InvalidOperationException($"The {typeof(NSData).Name} has not been created.");

                return NativeSliceUnsafeUtility.ConvertExistingDataToNativeSlice<byte>(GetBytes(this), 1, GetLength(this));
            }
        }

        public void Dispose() => NativeApi.CFRelease(ref m_Ptr);

        public override int GetHashCode() => m_Ptr.GetHashCode();
        public override bool Equals(object obj) => (obj is NSData) && Equals((NSData)obj);
        public bool Equals(NSData other) => m_Ptr == other.m_Ptr;
        public static bool operator==(NSData lhs, NSData rhs) => lhs.Equals(rhs);
        public static bool operator!=(NSData lhs, NSData rhs) => !lhs.Equals(rhs);

        [DllImport("__Internal", EntryPoint="UnityMC_NSData_getLength")]
        static extern int GetLength(NSData self);

        [DllImport("__Internal", EntryPoint="UnityMC_NSData_getBytes")]
        static extern unsafe void* GetBytes(NSData self);

        [DllImport("__Internal", EntryPoint="UnityMC_NSData_createWithBytes")]
        static extern unsafe IntPtr CreateWithBytes(void* bytes, int length);

        [DllImport("__Internal", EntryPoint="UnityMC_NSData_createWithBytesNoCopy")]
        static extern unsafe IntPtr CreateWithBytesNoCopy(void* bytes, int length, bool freeWhenDone);
    }
}

================
File: Assets/Scripts/Runtime/Multipeer/NSData.cs.meta
================
fileFormatVersion: 2
guid: 0aac506fdc0254d79b2479e6735d7ba3
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NSError.cs
================
using System;
using System.Runtime.InteropServices;

namespace Unity.iOS.Multipeer
{
    [StructLayout(LayoutKind.Sequential)]
    public struct NSError : IDisposable, IEquatable<NSError>
    {
        IntPtr m_Ptr;

        public bool Valid => m_Ptr != IntPtr.Zero;

        public NSErrorException ToException()
        {
            return new NSErrorException(Code, Description);
        }

        public long Code
        {
            get
            {
                if (!Valid)
                    throw new InvalidOperationException($"The {typeof(NSError).Name} is not valid.");

                return GetCode(this);
            }
        }

        public string Description
        {
            get
            {
                if (!Valid)
                    throw new InvalidOperationException($"The {typeof(NSError).Name} is not valid.");

                using (var description = GetLocalizedDescription(this))
                {
                    return description.ToString();
                }
            }
        }

        public void Dispose() => NativeApi.CFRelease(ref m_Ptr);
        public override int GetHashCode() => m_Ptr.GetHashCode();
        public override bool Equals(object obj) => (obj is NSError) && Equals((NSError)obj);
        public bool Equals(NSError other) => m_Ptr == other.m_Ptr;
        public static bool operator==(NSError lhs, NSError rhs) => lhs.Equals(rhs);
        public static bool operator!=(NSError lhs, NSError rhs) => !lhs.Equals(rhs);

        [DllImport("__Internal", EntryPoint="UnityMC_NSError_code")]
        static extern long GetCode(NSError error);

        [DllImport("__Internal", EntryPoint="UnityMC_NSError_localizedDescription")]
        static extern NSString GetLocalizedDescription(NSError error);
    }
}

================
File: Assets/Scripts/Runtime/Multipeer/NSError.cs.meta
================
fileFormatVersion: 2
guid: 10a04c15626774337abc28e3ed0dc046
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NSErrorException.cs
================
using System;

namespace Unity.iOS.Multipeer
{
    public class NSErrorException : Exception
    {
        public NSErrorException(long code, string description)
        : base($"NSError {code}: {description}")
        {
            Code = code;
            Description = description;
        }

        public long Code { get; private set; }

        public string Description { get; private set; }
    }
}

================
File: Assets/Scripts/Runtime/Multipeer/NSErrorException.cs.meta
================
fileFormatVersion: 2
guid: 491dc7d106d7642499e0ccfe7d11bf70
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/NSString.cs
================
using System;
using System.Runtime.InteropServices;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace Unity.iOS.Multipeer
{
    [StructLayout(LayoutKind.Sequential)]
    public struct NSString : IDisposable, IEquatable<NSString>
    {
        IntPtr m_Ptr;

        internal NSString(IntPtr existing) => m_Ptr = existing;

        public NSString(string text) => m_Ptr = CreateWithString(text, text.Length);

        public NSString(NSData serializedString)
        {
            if (!serializedString.Created)
                throw new ArgumentException("The serialized string is not valid.", nameof(serializedString));

            m_Ptr = Deserialize(serializedString);
        }

        public bool Created => m_Ptr != IntPtr.Zero;

        public int Length => GetLength(this);

        public override unsafe string ToString()
        {
            if (!Created)
                return string.Empty;

            using (var buffer = new NativeArray<byte>(GetLengthOfBytes(this), Allocator.TempJob, NativeArrayOptions.UninitializedMemory))
            {
                if (GetBytes(this, buffer.GetUnsafePtr(), buffer.Length))
                {
                    return Marshal.PtrToStringUni(new IntPtr(buffer.GetUnsafePtr()), Length);
                }
                else
                {
                    return string.Empty;
                }
            }
        }

        public NSData Serialize()
        {
            if (!Created)
                throw new InvalidOperationException($"The {typeof(NSString).Name} has not been created.");

            return Serialize(this);
        }

        public void Dispose() => NativeApi.CFRelease(ref m_Ptr);
        public override int GetHashCode() => m_Ptr.GetHashCode();
        public override bool Equals(object obj) => (obj is NSString) && Equals((NSString)obj);
        public bool Equals(NSString other) => m_Ptr == other.m_Ptr;
        public static bool operator==(NSString lhs, NSString rhs) => lhs.Equals(rhs);
        public static bool operator!=(NSString lhs, NSString rhs) => !lhs.Equals(rhs);

        [DllImport("__Internal", EntryPoint="UnityMC_NSString_createWithString")]
        static extern IntPtr CreateWithString([MarshalAs(UnmanagedType.LPWStr)] string text, int length);

        [DllImport("__Internal", EntryPoint="UnityMC_NSString_lengthOfBytesUsingEncoding")]
        static extern int GetLengthOfBytes(NSString self);

        [DllImport("__Internal", EntryPoint="UnityMC_NSString_getLength")]
        static extern int GetLength(NSString self);

        [DllImport("__Internal", EntryPoint="UnityMC_NSString_getBytes")]
        static extern unsafe bool GetBytes(NSString self, void* buffer, int length);

        [DllImport("__Internal", EntryPoint="UnityMC_NSString_serialize")]
        static extern NSData Serialize(NSString self);

        [DllImport("__Internal", EntryPoint="UnityMC_NSString_deserialize")]
        static extern IntPtr Deserialize(NSData data);
    }
}

================
File: Assets/Scripts/Runtime/Multipeer/NSString.cs.meta
================
fileFormatVersion: 2
guid: 2a2bbe15074f94af4b35f25e435174f6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Multipeer/Unity.XR.Samples.Multipeer.asmdef
================
{
    "name": "Unity.XR.Samples.Multipeer",
    "references": [],
    "includePlatforms": [
        "iOS"
    ],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": []
}

================
File: Assets/Scripts/Runtime/Multipeer/Unity.XR.Samples.Multipeer.asmdef.meta
================
fileFormatVersion: 2
guid: 999681c7ffab0480997e5c0752c60948
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/RGBImageCapture.cs
================
using System;
using System.IO;
using UnityEngine;
using UnityEngine.XR.ARFoundation;

public class RGBImageCapture : MonoBehaviour
{
    [SerializeField]
    private ARCameraManager cameraManager;

    private bool isSaving = false;

    void Awake()
    {
        if (cameraManager == null)
            cameraManager = FindAnyObjectByType<ARCameraManager>();

        if (cameraManager == null)
            Debug.LogError("ARCameraManager not found!");
    }

    public async void CaptureRGBFrame()
    {
        if (isSaving)
        {
            Debug.Log("Already saving an image, please wait...");
            return;
        }

        if (cameraManager == null)
        {
            Debug.LogError("Cannot capture RGB frame - ARCameraManager is null");
            return;
        }

        try
        {
            isSaving = true;
            Debug.Log("Starting RGB capture...");

            if (!cameraManager.TryAcquireLatestCpuImage(out UnityEngine.XR.ARSubsystems.XRCpuImage image))
            {
                Debug.LogError("Failed to acquire latest CPU image");
                return;
            }

            using (image)
            {
                string timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                string baseFilename = Path.Combine(Application.persistentDataPath, $"rgb_frame_{timestamp}");
                string pngPath = $"{baseFilename}.png";

                Debug.Log($"Preparing to save RGB image to: {pngPath}");

                var conversionParams = new UnityEngine.XR.ARSubsystems.XRCpuImage.ConversionParams
                {
                    inputRect = new RectInt(0, 0, image.width, image.height),
                    outputDimensions = new Vector2Int(image.width, image.height),
                    outputFormat = TextureFormat.RGB24,
                    transformation = UnityEngine.XR.ARSubsystems.XRCpuImage.Transformation.MirrorY
                };

                int size = image.GetConvertedDataSize(conversionParams);
                var buffer = new Unity.Collections.NativeArray<byte>(size, Unity.Collections.Allocator.Temp);

                try
                {
                    image.Convert(conversionParams, new Unity.Collections.NativeSlice<byte>(buffer));

                    var texture = new Texture2D(
                        conversionParams.outputDimensions.x,
                        conversionParams.outputDimensions.y,
                        TextureFormat.RGB24,
                        false);

                    texture.LoadRawTextureData(buffer);
                    texture.Apply();

                    // Convert to PNG
                    byte[] pngData = texture.EncodeToPNG();
                    if (pngData == null || pngData.Length == 0)
                    {
                        Debug.LogError("Failed to encode texture to PNG");
                        return;
                    }

                    // Ensure directory exists
                    string directory = Path.GetDirectoryName(pngPath);
                    if (!Directory.Exists(directory))
                    {
                        Directory.CreateDirectory(directory);
                    }

                    // Save PNG file
                    File.WriteAllBytes(pngPath, pngData);
                    Debug.Log($"Successfully saved RGB image to: {pngPath}");

                    // Save metadata
                    SaveMetadata(image, $"{baseFilename}.meta");

                    // Wait for file to be written
                    int attempts = 0;
                    while (!File.Exists(pngPath) && attempts < 10)
                    {
                        await System.Threading.Tasks.Task.Delay(100);
                        attempts++;
                    }

                    if (!File.Exists(pngPath))
                    {
                        Debug.LogError($"File was not created after save operation: {pngPath}");
                    }

                    // Clean up
                    Texture2D.Destroy(texture);
                }
                finally
                {
                    if (buffer.IsCreated)
                        buffer.Dispose();
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Error capturing RGB frame: {e.Message}\nStack trace: {e.StackTrace}");
        }
        finally
        {
            isSaving = false;
        }
    }

    private void SaveMetadata(UnityEngine.XR.ARSubsystems.XRCpuImage image, string filename)
    {
        try
        {
            var metadata = new ImageMetadata
            {
                width = image.width,
                height = image.height,
                timestamp = image.timestamp
            };

            string jsonMetadata = JsonUtility.ToJson(metadata, true);
            File.WriteAllText(filename, jsonMetadata);
            Debug.Log($"Successfully saved RGB metadata to: {filename}");
        }
        catch (Exception e)
        {
            Debug.LogError($"Error saving RGB metadata: {e.Message}");
        }
    }

    [Serializable]
    private struct ImageMetadata
    {
        public int width;
        public int height;
        public double timestamp;
    }
}

================
File: Assets/Scripts/Runtime/RGBImageCapture.cs.meta
================
fileFormatVersion: 2
guid: 81ea5a927d99f684ba2f24e5c513a884

================
File: Assets/Scripts/Runtime/ServerManager.cs
================
using System;
using System.IO;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.XR.ARFoundation.Samples.Assets.Scripts.Runtime;

public class ServerManager : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private TMP_InputField serverUriInput;
    [SerializeField] private GameObject settingsPanel;
    [SerializeField] private GameObject resultsPanel;
    [SerializeField] private Text resultText;
    [SerializeField] private Button saveSettingsButton;
    [SerializeField] private Button cancelButton;
    [SerializeField] private Button settingsButton;
    [SerializeField] private Button closeResultsPanelButton;

    [Header("Debug Settings")]
    [SerializeField] private bool useTestResponse = false;

    private static HttpClient httpClient;
    private string serverUri = "http://192.168.210.25:5000"; // Default URI

    public struct UploadParameters
    {
        public string timestamp;       // Added timestamp field
        public string basePath;        // Base path for all files
        public string depthPrefix;     // Prefix for depth files (e.g., "depth_frame_")
        public string rgbPrefix;       // Prefix for RGB files (e.g., "rgb_frame_")

        // Helper methods to get full paths
        public string GetDepthRawPath() => Path.Combine(basePath, $"{depthPrefix}{timestamp}.raw");
        public string GetDepthMetaPath() => Path.Combine(basePath, $"{depthPrefix}{timestamp}.meta");
        public string GetRgbImagePath() => Path.Combine(basePath, $"{rgbPrefix}{timestamp}.png");
        public string GetRgbMetaPath() => Path.Combine(basePath, $"{rgbPrefix}{timestamp}.meta");
    }

    private void OnEnable()
    {
        settingsPanel.SetActive(false);
        resultsPanel.SetActive(false);
    }

    void Awake()
    {
        httpClient = new HttpClient();

        if (serverUriInput != null)
            serverUriInput.text = serverUri;

        if (saveSettingsButton != null)
            saveSettingsButton.onClick.AddListener(SaveSettings);

        if (cancelButton != null)
            cancelButton.onClick.AddListener(HideSettingsPanel);

        if (settingsButton != null)
            settingsButton.onClick.AddListener(ShowSettingsPanel);

        if (closeResultsPanelButton != null)
            closeResultsPanelButton.onClick.AddListener(HideResultsPanel);
    }

    public void HideResultsPanel()
    {
        if (resultsPanel != null)
            resultsPanel.SetActive(false);
    }

    public void ShowResultsPanel()
    {
        if (resultsPanel != null)
            resultsPanel.SetActive(true);
    }

    public void ShowSettingsPanel()
    {
        if (settingsPanel != null)
            settingsPanel.SetActive(true);
    }

    public void HideSettingsPanel()
    {
        if (settingsPanel != null)
            settingsPanel.SetActive(false);
    }

    private void SaveSettings()
    {
        if (serverUriInput != null)
        {
            serverUri = serverUriInput.text;
            Debug.Log($"Server URI updated to: {serverUri}");
        }
        HideSettingsPanel();
    }

    private void DisplayNutritionResults(NutritionApiResponse response)
    {
        if (resultText == null) return;

        var sb = new StringBuilder();
        sb.AppendLine("Nutrition Analysis Results:\n");

        foreach (var macroData in response.macronutrients.data)
        {
            var nutritionInfo = FoodNutritionInfo.FromApiData(response.data, macroData);

            sb.AppendLine($"Food: {nutritionInfo.foodName.ToUpper()}");
            sb.AppendLine($"Estimated Volume (EV): {nutritionInfo.estimatedVolume:F2} {nutritionInfo.volumeUnit}");
            sb.AppendLine($"Calculated Weight (from EV): {nutritionInfo.calculatedWeight} {nutritionInfo.weightUnit}");
            sb.AppendLine("Macronutrients:");
            sb.AppendLine($"  Calories: {nutritionInfo.calories} ");
            sb.AppendLine($"  Protein: {nutritionInfo.protein:F1}g");
            sb.AppendLine($"  Fat: {nutritionInfo.fat:F1}g");
            sb.AppendLine($"  Carbs: {nutritionInfo.carbohydrates:F1}g\n");
        }

        resultText.text = sb.ToString();
        ShowResultsPanel();
    }

    public async Task<bool> UploadDepthData(UploadParameters request)
    {
        try
        {
            Debug.Log("Starting file upload process...");

            httpClient.Timeout = TimeSpan.FromMinutes(5);

            using (var multipartContent = new MultipartFormDataContent())
            {
                try
                {
                    // 3. Add RGB image with explicit error handling
                    string rgbPath = request.GetRgbImagePath();
                    if (File.Exists(rgbPath))
                    {
                        try
                        {
                            byte[] rgbFileBytes = await File.ReadAllBytesAsync(rgbPath);
                            var rgbContent = new ByteArrayContent(rgbFileBytes);
                            multipartContent.Add(rgbContent, "rgb_image", Path.GetFileName(rgbPath));
                            Debug.Log($"Successfully added RGB image ({rgbFileBytes.Length} bytes)");
                        }
                        catch (IOException ex)
                        {
                            Debug.LogError($"Error reading RGB file: {ex.Message}");
                            return false;
                        }
                    }
                    else
                    {
                        Debug.LogError($"RGB file not found at: {rgbPath}");
                        return false;
                    }

                    // 4. Add depth image with explicit error handling
                    if (File.Exists(request.GetDepthRawPath()))
                    {
                        try
                        {
                            byte[] depthFileBytes = await File.ReadAllBytesAsync(request.GetDepthRawPath());
                            var depthContent = new ByteArrayContent(depthFileBytes);
                            multipartContent.Add(depthContent, "depth_image", Path.GetFileName(request.GetDepthRawPath()));
                            Debug.Log($"Successfully added depth image ({depthFileBytes.Length} bytes)");
                        }
                        catch (IOException ex)
                        {
                            Debug.LogError($"Error reading depth file: {ex.Message}");
                            return false;
                        }
                    }
                    else
                    {
                        Debug.LogError($"Depth file not found at: {request.GetDepthRawPath()}");
                        return false;
                    }

                    // 5. Add metadata files with explicit error handling
                    try
                    {
                        if (File.Exists(request.GetRgbMetaPath()))
                        {
                            string rgbMetaContent = await File.ReadAllTextAsync(request.GetRgbMetaPath());
                            var rgbMetaTextContent = new StringContent(rgbMetaContent);
                            multipartContent.Add(rgbMetaTextContent, "rgb_meta");
                            Debug.Log("Added RGB metadata");
                        }

                        if (File.Exists(request.GetDepthMetaPath()))
                        {
                            string depthMetaContent = await File.ReadAllTextAsync(request.GetDepthMetaPath());
                            var depthMetaTextContent = new StringContent(depthMetaContent);
                            multipartContent.Add(depthMetaTextContent, "depth_meta");
                            Debug.Log("Added depth metadata");
                        }
                    }
                    catch (IOException ex)
                    {
                        Debug.LogError($"Error reading metadata files: {ex.Message}");
                        return false;
                    }

                    // 6. Send request with retry logic
                    const int maxRetries = 3;
                    for (int retry = 0; retry < maxRetries; retry++)
                    {
                        try
                        {
                            Debug.Log($"Sending files to server (attempt {retry + 1}/{maxRetries}): {serverUri}/process");

                            using (var response = await httpClient.PostAsync($"{serverUri}/process", multipartContent))
                            {
                                Debug.Log($"Server responded with status: {response.StatusCode}");

                                if (response.IsSuccessStatusCode)
                                {
                                    if (useTestResponse)
                                    {
                                        Debug.Log("Using test response data");
                                        var dummyResponse = NutritionTestData.CreateDummyResponse();
                                        DisplayNutritionResults(dummyResponse);
                                        return true;
                                    }
                                    else
                                    {
                                        string jsonResponse = await response.Content.ReadAsStringAsync();
                                        var nutritionResponse = JsonUtility.FromJson<NutritionApiResponse>(jsonResponse);
                                        DisplayNutritionResults(nutritionResponse);
                                        return true;
                                    }
                                }
                                else
                                {
                                    string errorContent = await response.Content.ReadAsStringAsync();
                                    Debug.LogError($"Server returned error {response.StatusCode}: {errorContent}");

                                    // Only retry on specific status codes
                                    if ((int)response.StatusCode < 500)  // Don't retry on 4xx errors
                                        return false;

                                    if (retry < maxRetries - 1)
                                        await Task.Delay(1000 * (retry + 1));  // Exponential backoff
                                }
                            }
                        }
                        catch (HttpRequestException ex)
                        {
                            Debug.LogError($"Network error (attempt {retry + 1}): {ex.Message}");
                            if (retry < maxRetries - 1)
                                await Task.Delay(1000 * (retry + 1));
                        }
                    }

                    Debug.LogError("Failed to upload after all retry attempts");
                    return false;
                }
                catch (Exception e)
                {
                    Debug.LogError($"Error preparing form data: {e.Message}\nStack trace: {e.StackTrace}");
                    return false;
                }
            }
        }
        catch (Exception e)
        {
            Debug.LogError($"Error in upload process: {e.Message}\nStack trace: {e.StackTrace}");
            return false;
        }
    }

    private void OnDestroy()
    {
        httpClient?.Dispose();
    }

    // For testing the UI directly from the Unity Editor
    [ContextMenu("Test Display With Dummy Data")]
    private void TestDisplayWithDummyData()
    {
        var dummyResponse = NutritionTestData.CreateDummyResponse();
        DisplayNutritionResults(dummyResponse);
    }
}

================
File: Assets/Scripts/Runtime/ServerManager.cs.meta
================
fileFormatVersion: 2
guid: 85368df0e88173945a0ac95fedd9ed40

================
File: Assets/Scripts/Runtime/Triggers.meta
================
fileFormatVersion: 2
guid: b677301bed734447191a0e24aa0bc875
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Triggers/RequirementsTrigger.cs
================
using System.Collections.Generic;
using UnityEngine.Events;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequirementsTrigger : MonoBehaviour
    {
        [SerializeReference, SelectImplementation(typeof(IBooleanExpression))]
        List<IBooleanExpression> m_Requirements = new();
        public IList<IBooleanExpression> requirements => m_Requirements;

        [SerializeField, Tooltip("Invoked on Start if given requirements are met.")]
        UnityEvent requirementsMet;

        [SerializeField, Tooltip("Invoked on Start if given requirements are not met.")]
        UnityEvent requirementsNotMet;

        void Start()
        {
            foreach (var r in m_Requirements)
            {
                if (!r.Evaluate())
                {
                    requirementsNotMet?.Invoke();
                    return;
                }
            }

            requirementsMet?.Invoke();
        }
    }
}

================
File: Assets/Scripts/Runtime/Triggers/RequirementsTrigger.cs.meta
================
fileFormatVersion: 2
guid: 4e53ecde5a3434f16a78efd36f402cc0

================
File: Assets/Scripts/Runtime/UI.meta
================
fileFormatVersion: 2
guid: 02a12bc9566ff423d9c949cc6408db7c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/AnchorScrollViewEntry.cs
================
using System;
using System.Threading;
using System.Threading.Tasks;
using TMPro;
using UnityEngine.Events;
using UnityEngine.UI;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class AnchorScrollViewEntry : MonoBehaviour
    {
        [Header("Entry References")]
        [SerializeField]
        Button m_ActionButton;

        [SerializeField]
        Button m_EraseButton;

        [SerializeField]
        TextMeshProUGUI m_AnchorDisplayLabel;
        public string AnchorDisplayText => m_AnchorDisplayLabel.text;

        [Header("Action Button References")]
        [SerializeField]
        GameObject m_ActionButtonText;

        [SerializeField]
        GameObject m_ActionButtonIcon;
        
        [SerializeField]
        LoadingVisualizer m_ActionLoadingVisualizer;

        [SerializeField]
        GameObject m_ActionSuccessVisualizer;

        [SerializeField]
        GameObject m_ActionErrorVisualizer;
        
        [Header("Erase Button References")]
        [SerializeField]
        GameObject m_EraseButtonIcon;

        [SerializeField]
        LoadingVisualizer m_EraseLoadingVisualizer;
        
        [SerializeField]
        GameObject m_EraseSuccessVisualizer;

        [SerializeField]
        GameObject m_EraseErrorVisualizer;

        public ARAnchor representedAnchor { get; set; }

        public SerializableGuid persistentAnchorGuid { get; set; }

        [SerializeField, Tooltip("The event raised when the action button is clicked.")]
        UnityEvent<AnchorScrollViewEntry> m_RequestAction = new();
        public UnityEvent<AnchorScrollViewEntry> requestAction => m_RequestAction;

        [SerializeField, Tooltip("The event raised when the erase button is clicked.")]
        UnityEvent<AnchorScrollViewEntry> m_RequestEraseAnchor = new();
        public UnityEvent<AnchorScrollViewEntry> requestEraseAnchor => m_RequestEraseAnchor;

        CancellationTokenSource m_CancellationTokenSource = new();

        public void StartActionLoadingAnimation()
        {
            m_ActionButtonText.SetActive(false);
            m_ActionButtonIcon.SetActive(false);
            m_ActionLoadingVisualizer.StartAnimating();
        }

        public void StopActionLoadingAnimation()
        {
            m_ActionLoadingVisualizer.StopAnimating();
            m_ActionButtonIcon.SetActive(true);
            m_ActionButtonText.SetActive(true);
        }
        
        public void StartEraseLoadingAnimation()
        {
            m_EraseButtonIcon.SetActive(false);
            m_EraseLoadingVisualizer.StartAnimating();
        }

        public void StopEraseLoadingAnimation()
        {
            m_EraseLoadingVisualizer.StopAnimating();
            m_EraseButtonIcon.SetActive(true);
        }

        public void EnableActionButton(bool isOn)
        {
            m_ActionButton.SetEnabled(isOn);
        }

        public void EnableEraseButton(bool isOn)
        {
            m_EraseButton.interactable = isOn;
        }

        public void ShowEraseButton(bool isOn)
        {
            m_EraseButton.gameObject.SetActive(isOn);
        }

        public async Task ShowActionResult(bool isSuccessful, float durationInSeconds)
        {
            var visualizer = isSuccessful ? m_ActionSuccessVisualizer : m_ActionErrorVisualizer;
            visualizer.SetActive(true);
            m_ActionButtonText.SetActive(false);
            m_ActionButtonIcon.SetActive(false);

            try
            {
                await Task.Delay((int)(durationInSeconds * 1000), m_CancellationTokenSource.Token);
            }
            catch (OperationCanceledException)
            {
                // do nothing
            }

            visualizer.SetActive(false);
            m_ActionButtonText.SetActive(true);
            m_ActionButtonIcon.SetActive(true);
        }

        public async Task ShowEraseResult(bool isSuccessful, float durationInSeconds)
        {
            var visualizer = isSuccessful ? m_EraseSuccessVisualizer : m_EraseErrorVisualizer;
            visualizer.SetActive(true);
            m_EraseButtonIcon.SetActive(false);

            try
            {
                await Task.Delay((int)(durationInSeconds * 1000), m_CancellationTokenSource.Token);
            }
            catch (OperationCanceledException)
            {
                // do nothing
            }

            visualizer.SetActive(false);
            m_EraseButtonIcon.SetActive(true);
        }

        public void SetDisplayedAnchorLabel(string label)
        {
            m_AnchorDisplayLabel.text = label;
        }

        void OnEnable()
        {
            m_CancellationTokenSource = new();
            m_ActionButton.onClick.AddListener(OnRequestActionButtonClicked);
            m_EraseButton.onClick.AddListener(OnEraseAnchorButtonClicked);
        }

        void OnDisable()
        {
            m_ActionButton.onClick.RemoveListener(OnRequestActionButtonClicked);
            m_EraseButton.onClick.RemoveListener(OnEraseAnchorButtonClicked);
            m_CancellationTokenSource.Cancel();
        }

        void OnDestroy()
        {
            m_ActionButton.onClick.RemoveAllListeners();
            m_EraseButton.onClick.RemoveAllListeners();
        }

        void OnRequestActionButtonClicked()
        {
            m_RequestAction?.Invoke(this);
        }

        void OnEraseAnchorButtonClicked()
        {
            m_RequestEraseAnchor?.Invoke(this);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/AnchorScrollViewEntry.cs.meta
================
fileFormatVersion: 2
guid: f8da892e0782941978d89aa748aed0e0

================
File: Assets/Scripts/Runtime/UI/BackButton.cs
================
using UnityEngine.InputSystem;
using UnityEngine.SceneManagement;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class BackButton : MonoBehaviour
    {
        [SerializeField]
        GameObject m_BackButton;

        public GameObject backButton
        {
            get => m_BackButton;
            set => m_BackButton = value;
        }

        void Start()
        {
            if (Application.CanStreamedLevelBeLoaded(MenuLoader.GetMenuSceneName()))
                m_BackButton.SetActive(true);
        }

        void Update()
        {
            // Handles Android physical back button
            if (Keyboard.current != null && Keyboard.current.escapeKey.wasPressedThisFrame)
                BackButtonPressed();
        }

        public void BackButtonPressed()
        {
            string menuSceneName = MenuLoader.GetMenuSceneName();
            if (Application.CanStreamedLevelBeLoaded(menuSceneName))
                SceneManager.LoadScene(menuSceneName, LoadSceneMode.Single);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/BackButton.cs.meta
================
fileFormatVersion: 2
guid: 9909048d5fe6c41468a28c79b85916d5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/ButtonUtils.cs
================
using TMPro;
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public static class ButtonUtils
    {
        public static readonly Color enabledButtonTextColor = new(228f / 255, 228f / 255, 228f / 255, 1.0f);

        public static readonly Color disabledButtonTextColor = new(228f / 255, 228f / 255, 228f / 255, 0.1f);

        public static void SetEnabled(this Button button, bool isOn)
        {
            button.interactable = isOn;

            var text = button.GetComponentInChildren<TextMeshProUGUI>();
            if (text == null)
                return;

            text.color = isOn ? enabledButtonTextColor : disabledButtonTextColor;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/ButtonUtils.cs.meta
================
fileFormatVersion: 2
guid: f9c06bb4a3bb49b995039a73f50b3d14
timeCreated: 1702858610

================
File: Assets/Scripts/Runtime/UI/ButtonUtilsComponent.cs
================
using TMPro;
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Exposes <see cref="ButtonUtils"/> via public instance methods, so that they can be used via `UnityEvent`.
    /// </summary>
    public class ButtonUtilsComponent : MonoBehaviour
    {
        public void DisableButton(Button button)
        {
            button.SetEnabled(false);
        }

        public void EnableButton(Button button)
        {
            button.SetEnabled(true);
        }

        public void DisableText(TextMeshProUGUI text)
        {
            text.color = ButtonUtils.disabledButtonTextColor;
        }

        public void EnableText(TextMeshProUGUI text)
        {
            text.color = ButtonUtils.enabledButtonTextColor;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/ButtonUtilsComponent.cs.meta
================
fileFormatVersion: 2
guid: c617d23d6d09148fb870ff014dbc0b18

================
File: Assets/Scripts/Runtime/UI/CameraConfigurationDropdown.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using Unity.Collections;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class CameraConfigurationDropdown : MonoBehaviour
    {
        [SerializeField]
        ARCameraManager m_CameraManager;

        [SerializeField]
        TMP_Dropdown m_CameraConfigurationDropdown;

        XRCameraConfiguration m_CurrentCameraConfiguration;

        void Reset()
        {
            TryInitializeSerializedFields();
        }

        void Awake()
        {
            if (m_CameraManager == null)
                TryInitializeSerializedFields();

            m_CameraConfigurationDropdown.onValueChanged.AddListener(delegate { OnCameraDropdownValueChanged(m_CameraConfigurationDropdown); });
            StartCoroutine(PopulateCameraDropdown());
        }

        void LateUpdate()
        {
            var cameraConfigOption = m_CameraManager.currentConfiguration;
            if(cameraConfigOption.HasValue && cameraConfigOption.Value != m_CurrentCameraConfiguration)
                m_CurrentCameraConfiguration = cameraConfigOption.Value;
        }

        void OnCameraDropdownValueChanged(TMP_Dropdown dropdown)
        {
            var configurationIndex = dropdown.value;
            using var configurations = m_CameraManager.GetConfigurations(Allocator.Temp);
            var configuration = configurations[configurationIndex];
            m_CameraManager.currentConfiguration = configuration;
        }

        IEnumerator PopulateCameraDropdown()
        {
            yield return null;

            if (m_CameraManager == null || m_CameraManager.subsystem is not {running: true})
                yield break;

            using var configurations = m_CameraManager.GetConfigurations(Allocator.Temp);

            var configurationNames = new List<string>();
            foreach (var config in configurations)
            {
                configurationNames.Add($"{config.width}x{config.height}{(config.framerate.HasValue ? $" at {config.framerate.Value} Hz" : "")}");
            }
            m_CameraConfigurationDropdown.AddOptions(configurationNames);

            var currentConfig = m_CameraManager.currentConfiguration;
            for (int i = 0; i < configurations.Length; ++i)
            {
                if (currentConfig == configurations[i])
                {
                    m_CameraConfigurationDropdown.value = i;
                }
            }
        }

        [ContextMenu("Try Initialize Serialized Fields")]
        void TryInitializeSerializedFields()
        {
            m_CameraManager = FindAnyObjectByType<ARCameraManager>();
            m_CameraConfigurationDropdown = GetComponentInChildren<TMP_Dropdown>();
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/CameraConfigurationDropdown.cs.meta
================
fileFormatVersion: 2
guid: 68201e867b069497687732f578ab7961
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/CheckRenderLine.cs
================
using UnityEngine;
using UnityEngine.XR.Interaction.Toolkit;
using UnityEngine.XR;

[RequireComponent(typeof(UnityEngine.XR.Interaction.Toolkit.Interactors.Visuals.XRInteractorLineVisual))]
#pragma warning disable CS0618 // temporary fix to remove console warnings while we decide what to do with this component
[RequireComponent(typeof(ActionBasedController))]
#pragma warning restore CS0618
public class CheckRenderLine : MonoBehaviour
{
#pragma warning disable CS0618
    ActionBasedController m_Controller;
#pragma warning restore CS0618
    UnityEngine.XR.Interaction.Toolkit.Interactors.Visuals.XRInteractorLineVisual m_InteractorLine;

    [SerializeField]
    Camera m_CameraAR;

    public Camera cameraAR
    {
        get => m_CameraAR;
        set => m_CameraAR = value;
    }

    void LogDeprecatedWarning()
    {
        Debug.LogWarning($"{nameof(CheckRenderLine)} uses deprecated functionality from XRI 2.0. Avoid using this component.", this);
    }
    
    void Reset()
    {
        LogDeprecatedWarning();
    }

    void Start()
    {
        LogDeprecatedWarning();

        if(!m_CameraAR.stereoEnabled)
        {
            enabled = false;
        }
#pragma warning disable CS0618
        m_Controller = GetComponent<ActionBasedController>();
#pragma warning restore CS0618
        m_InteractorLine = GetComponent<UnityEngine.XR.Interaction.Toolkit.Interactors.Visuals.XRInteractorLineVisual>();
    }

    void Update()
    {
        HandleLineRender();
    }

    void HandleLineRender()
    {
        var state = m_Controller.currentControllerState;
        if(state != null && (state.inputTrackingState & InputTrackingState.Position) != 0)
        {
            m_InteractorLine.enabled = true;
            if (m_InteractorLine.reticle != null)
                m_InteractorLine.reticle.SetActive(true);
        }
        else
        {
            m_InteractorLine.enabled = false;
            if (m_InteractorLine.reticle != null)
                m_InteractorLine.reticle.SetActive(false);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/CheckRenderLine.cs.meta
================
fileFormatVersion: 2
guid: 7b5c3fcac7a413e4681907dd337b357a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/CheckRuntimeDepth.cs
================
using System;
using System.Text;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.XR.ARFoundation;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// This component tests for depth functionality and enables/disables
    /// a text message on the screen reporting that depth is not suppoted.
    /// </summary>
    public class CheckRuntimeDepth : MonoBehaviour
    {
        [SerializeField]
        [Tooltip("The AROcclusionManager which will manage depth functionality.")]
        AROcclusionManager m_OcclusionManager;

        /// <summary>
        /// Get or set the <c>AROcclusionManager</c>.
        /// </summary>
        public AROcclusionManager occlusionManager
        {
            get => m_OcclusionManager;
            set => m_OcclusionManager = value;
        }

        [SerializeField]
        Text m_DepthAvailabilityInfo;

        /// <summary>
        /// The UI Text used to display information about the availability of depth functionality.
        /// </summary>
        public Text depthAvailabilityInfo
        {
            get => m_DepthAvailabilityInfo;
            set => m_DepthAvailabilityInfo = value;
        }

        void Update()
        {
            Debug.Assert(m_OcclusionManager != null, "no occlusion manager");
            Debug.Assert(m_DepthAvailabilityInfo != null, "no text box");
            var descriptor = m_OcclusionManager.descriptor;
            m_DepthAvailabilityInfo.enabled =
                descriptor == null ||
                (descriptor.humanSegmentationStencilImageSupported == Supported.Unsupported &&
                descriptor.humanSegmentationDepthImageSupported == Supported.Unsupported &&
                descriptor.environmentDepthImageSupported == Supported.Unsupported);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/CheckRuntimeDepth.cs.meta
================
fileFormatVersion: 2
guid: 3604c16c635de4e029b7ec13aed43bee
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/ColorAsset.cs
================
namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Use this class to store colors with notes in an easy-to-find location in your file system.
    /// </summary>
    public class ColorAsset : ScriptableObject
    {
        [SerializeField]
        Color m_Color;

        public Color color => m_Color;

        [SerializeField]
        [TextArea(4, 4)]
        [Space(4)]
        string m_Notes;
    }
}

================
File: Assets/Scripts/Runtime/UI/ColorAsset.cs.meta
================
fileFormatVersion: 2
guid: fb408ebb1fba9488ea74f34a97a917f0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/LoadingVisualizer.cs
================
using System;
using System.Threading;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class LoadingVisualizer : MonoBehaviour
    {
        const float k_LoadingVisualizerSpinRateInDegPerSecond = 350;

        CancellationTokenSource m_TokenSource = new();

        public void StartAnimating()
        {
            gameObject.SetActive(true);
            if (!m_TokenSource.IsCancellationRequested)
            {
                m_TokenSource.Cancel();
            }

            m_TokenSource = new();
            AnimateLoading(m_TokenSource.Token);
        }

        public void StopAnimating()
        {
            m_TokenSource.Cancel();
            gameObject.SetActive(false);
        }

        async void AnimateLoading(CancellationToken token)
        {
            while (!token.IsCancellationRequested)
            {
                var rotation = transform.rotation;
                var zAxisOffset = (-k_LoadingVisualizerSpinRateInDegPerSecond * Time.deltaTime) % 360f;
                rotation = Quaternion.Euler(
                    rotation.eulerAngles.x,
                    rotation.eulerAngles.y,
                    rotation.eulerAngles.z + zAxisOffset);

                transform.rotation = rotation;
                try
                {
                    await Awaitable.NextFrameAsync(token);
                }
                catch (OperationCanceledException)
                {
                    // do nothing
                }
            }
        }

        void OnDisable()
        {
            if (!m_TokenSource.IsCancellationRequested)
                m_TokenSource.Cancel();
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/LoadingVisualizer.cs.meta
================
fileFormatVersion: 2
guid: 7aa5b8ba3886b46508d29e0ae1a116ea

================
File: Assets/Scripts/Runtime/UI/LogObject.cs
================
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class LogObject : MonoBehaviour
    {
        // Start is called before the first frame update
        void Start()
        {
        
        }

        // Update is called once per frame
        void Update()
        {
        
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/LogObject.cs.meta
================
fileFormatVersion: 2
guid: 8196433303bdd4694bfbe64c068e3074
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/LogObjectPool.cs
================
using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using TMPro;
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Manages an object pool to display application logs to the screen.
    /// </summary>
    /// <remarks>
    /// This component is designed to work as part of a specific prefab structure and is not currently safe to add
    /// as a standalone component.
    /// </remarks>
    [AddComponentMenu("")]
    public class LogObjectPool : MonoBehaviour
    {
        [SerializeField, Range(0, 9999)]
        [Tooltip("Total number of GameObjects in the object pool.")]
#pragma warning disable CS0414
        int m_PoolSize = 20;
#pragma warning restore CS0414

        /// <summary>
        /// Object pool is initialized by <c>LogObjectPoolEditor</c> when user presses the "Regenerate Object Pool" button.
        /// </summary>
        [SerializeField]
        List<TextMeshProUGUI> m_Pool = new();

        [SerializeField]
        ScrollRect m_ScrollRect;

        [SerializeField]
        RectTransform m_ScrollViewContent;

        [SerializeField]
        [Tooltip("One or more template GameObjects to repeatedly instantiate in the object pool.")]
        List<GameObject> m_TemplateObjects;

        [SerializeField]
        float m_ObjectHeight;

        int m_NumObjectsEnabled;

        void Start()
        {
            if (m_ScrollViewContent == null)
            {
                Debug.LogError($"{nameof(LogObjectPool)} component on {name} has a null Scroll View Content.", this);
                return;
            }

            Application.logMessageReceived += HandleLog;
        }

        void OnDestroy()
        {
            Application.logMessageReceived -= HandleLog;
        }

        void HandleLog(string logString, string stackTrace, LogType type)
        {
            if (m_NumObjectsEnabled == m_Pool.Count)
            {
                for (var i = 0; i < m_NumObjectsEnabled - 1; i++)
                {
                    m_Pool[i].text = m_Pool[i + 1].text;
                }
            }

            m_Pool[GetIndexOfLastObject()].text = logString;

            if (m_NumObjectsEnabled < m_Pool.Count)
            {
                m_Pool[m_NumObjectsEnabled].transform.parent.gameObject.SetActive(true);
                m_ScrollViewContent.SetHeight(m_ScrollViewContent.GetHeight() + m_ObjectHeight);
                m_NumObjectsEnabled++;
            }

            m_ScrollRect.normalizedPosition = new Vector2(0, 0);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        int GetIndexOfLastObject()
        {
            if (m_NumObjectsEnabled < m_Pool.Count)
                return m_NumObjectsEnabled;

            return m_NumObjectsEnabled - 1;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/LogObjectPool.cs.meta
================
fileFormatVersion: 2
guid: 35bd0aecd08e442ad91cd4234244d422
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/MenuCategory.cs
================
using System;
using System.Collections.Generic;
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [RequireComponent(typeof(Button))]
    [DisallowMultipleComponent]
    public class MenuCategory : MonoBehaviour
    {
        const string k_MenuSelectorErrorMsg =
            "Could not find a MenuSelector component in the scene. Add a MenuSelector then Reset this component.";

        [SerializeField, Tooltip("Children of this GameObject should have SceneLauncher components.")]
        GameObject m_CategoryRootGameObject;

        [SerializeField, Tooltip("Will be displayed at the top of the Menu scene when this category is selected.")]
        string m_CategoryName;

        [SerializeField, HideInInspector]
        Button m_Button;

        [SerializeField, HideInInspector]
        MenuSelector m_MenuSelector;

        List<IList<IBooleanExpression>> m_AllRequirementsInCategory = new();

        void Awake()
        {
            if (m_CategoryRootGameObject == null)
            {
                Debug.LogError($"{nameof(MenuCategory)} component on {name} has null Inspector properties and will be disabled.", this);
                return;
            }

            var sceneLaunchers = m_CategoryRootGameObject.GetComponentsInChildren<SceneLauncher>();
            foreach (var s in sceneLaunchers)
            {
                m_AllRequirementsInCategory.Add(s.sceneDescriptor.requirements);
            }
        }

        void OnEnable()
        {
            foreach (var sceneRequirements in m_AllRequirementsInCategory)
            {
                // Only enable the menu button if at least one sample scene in the category is supported on this device
                if (sceneRequirements.EvaluateAll())
                {
                    m_Button.onClick.AddListener(SelectCategory);
                    return;
                }
            }

            m_Button.SetEnabled(false);
        }

        void OnDisable()
        {
            m_Button.onClick.RemoveListener(SelectCategory);
        }
        
        void SelectCategory()
        {
            if (m_MenuSelector == null)
            {
                m_MenuSelector = FindAnyObjectByType<MenuSelector>();
                if (m_MenuSelector == null)
                {
                    Debug.LogError(k_MenuSelectorErrorMsg, this);
                    return;
                }
            }

            m_MenuSelector.SelectMenu(m_CategoryRootGameObject);
            m_MenuSelector.SetTitleLabelMenuName(m_CategoryName);
        }

        void Reset()
        {
            m_Button = GetComponent<Button>();
            m_MenuSelector = FindAnyObjectByType<MenuSelector>();

            if (m_MenuSelector == null)
                Debug.LogError(k_MenuSelectorErrorMsg, this);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/MenuCategory.cs.meta
================
fileFormatVersion: 2
guid: 645c16330fd24ac8b2088a8851ba11a0
timeCreated: 1702858783

================
File: Assets/Scripts/Runtime/UI/MenuFollowCamera.cs
================
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [RequireComponent(typeof(Canvas))]
    [RequireComponent(typeof(CanvasScaler))]
    [RequireComponent(typeof(RectTransform))]
    public class MenuFollowCamera : MonoBehaviour
    {
        bool m_CameraFollow;

        [SerializeField]
        float m_SmoothFactor;
        public float smoothFactor
        {
            get => m_SmoothFactor;
            set => m_SmoothFactor = value;
        }

        [SerializeField]
        float m_Distance;
        public float distance
        {
            get => m_Distance;
            set => m_Distance = value;
        }

        [SerializeField]
        Camera m_CameraAR;
        public Camera cameraAR
        {
            get => m_CameraAR;
            set => m_CameraAR = value;
        }

        void Start()
        {
            var menu = GetComponent<Canvas>();
            var scaler = GetComponent<CanvasScaler>();

#if UNITY_IOS || UNITY_ANDROID || UNITY_EDITOR || UNITY_STANDALONE
            menu.renderMode = RenderMode.ScreenSpaceOverlay;
            scaler.matchWidthOrHeight = .5f;
#else
            m_CameraFollow = true;
            menu.renderMode = RenderMode.WorldSpace;
            var rectTransform = GetComponent<RectTransform>();
            rectTransform.sizeDelta = new Vector2(rectTransform.sizeDelta.x, 575);
#endif
        }

        void Update()
        {
            if (!m_CameraFollow)
                return;

            var cameraTransform = m_CameraAR.transform;
            Vector3 targetPosition = cameraTransform.position + cameraTransform.forward * distance;
            Vector3 currentPosition = transform.position;

            transform.SetPositionAndRotation(
                Vector3.Lerp(currentPosition, targetPosition, m_SmoothFactor),
                cameraTransform.rotation);

            float height;
            if (m_CameraAR.orthographic)
                height = m_CameraAR.orthographicSize * 2;
            else
                height = distance * Mathf.Tan(Mathf.Deg2Rad * (m_CameraAR.fieldOfView * 0.5f));

            float heightScale = height / m_CameraAR.scaledPixelHeight;
            transform.localScale = new Vector3(heightScale, heightScale, 1);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/MenuFollowCamera.cs.meta
================
fileFormatVersion: 2
guid: c9d21e2a0acaa4b48b2238e9614a7dfe
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/MenuLoader.cs
================
using UnityEngine.SceneManagement;
using UnityEngine.XR.ARSubsystems;
using UnityEngine.XR.OpenXR;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Loads the correct Menu scene based on the id of the currently loaded <see cref="XRSessionSubsystem"/>.
    /// </summary>
    [DefaultExecutionOrder(-9999)]
    public class MenuLoader : MonoBehaviour
    {
        const string k_DefaultMenuScene = "Menu";
        const string k_MetaMenuScene = "MetaMenu";
        const string k_HololensMenuScene = "HololensMenu";

        void Awake()
        {
            LoadMenuScene();
        }

        public static string GetMenuSceneName()
        {
            if (Application.platform == RuntimePlatform.WSAPlayerARM && OpenXRRuntime.name == "Windows Mixed Reality Runtime") 
            {
                return k_HololensMenuScene;
            }

            var loader = LoaderUtility.GetActiveLoader();
            var sessionSubsystem = loader != null ? loader.GetLoadedSubsystem<XRSessionSubsystem>() : null;

            if (sessionSubsystem == null)
            {
                // Could be null if user does not have "Initialize XR on Startup" enabled in XR Plug-in Management
                return k_DefaultMenuScene;
            }

            // We switch on Session Descriptor id because we can't guarantee with current preprocessor directives whether
            // a provider package (and its types) will be present. For example, UNITY_ANDROID could signal that either
            // ARCore or OpenXR loader is present. Because we don't know for sure, we are unable to switch on the loader
            // type without introducing a build-time error in case that package was stripped.
            switch (sessionSubsystem.subsystemDescriptor.id)
            {
                case "Meta-Session":
                    return k_MetaMenuScene;
                case "ARKit-Session":
                case "ARCore-Session":
                case "XRSimulation-Session":
                default:
                    // Default case includes other third-party providers
                    return k_DefaultMenuScene;
            }
        }

        public static bool IsHmdDevice()
        {
            var sceneName = GetMenuSceneName();
            return (sceneName == k_MetaMenuScene) || (sceneName == k_HololensMenuScene);
        }

        public static void LoadMenuScene()
        {
            var sceneName = GetMenuSceneName();
            if (Application.CanStreamedLevelBeLoaded(sceneName))
                SceneManager.LoadScene(sceneName, LoadSceneMode.Single);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/MenuLoader.cs.meta
================
fileFormatVersion: 2
guid: f9746e0e155a448bc9ea4b9d6aba088a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/MenuSelector.cs
================
using System;
using TMPro;
using UnityEngine;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Controls the Samples Menu UI and scene loading functionality.
    /// </summary>
    /// <remarks>
    /// This class assumes that you only use it in a single Menu scene in the project, that this on the Main Menu
    /// GameObject, that all menu GameObjects are siblings of the Main Menu, and that all menu GameObjects have unique
    /// names.
    /// </remarks>
    public class MenuSelector : MonoBehaviour
    {
        const string k_DefaultTitleLabel = "AR Foundation Samples";

        static GameObject s_SelectedMenu;

        /// <summary>
        /// We statically cache information about the selected menu so that we can recover the menu state after the
        /// scene is unloaded and reloaded again.
        /// </summary>
        static MenuInfo s_SelectedMenuInfo;

        [SerializeField]
        TextMeshProUGUI m_TitleLabel;

        [SerializeField]
        GameObject m_BackButton;

        void Awake()
        {
            if (s_SelectedMenuInfo == null)
            {
                s_SelectedMenu = gameObject;
                s_SelectedMenuInfo = new MenuInfo(name, null);
            }
            else
            {
                // If we have a selected menu on awake, this means the scene was unloaded and reloaded.
                // In this case our selected menu GameObject will be null, but we can find it again by name.
                s_SelectedMenu = transform.parent.Find(s_SelectedMenuInfo.gameObjectName).gameObject;
                if (s_SelectedMenuInfo.menuName != null)
                    SetTitleLabelMenuName(s_SelectedMenuInfo.menuName);

                // Hide the main menu in this case
                gameObject.SetActive(false);
            }

            SelectMenu(s_SelectedMenu.gameObject);
        }

        void OnDestroy()
        {
            s_SelectedMenu = null;
        }

        public void SelectMenu(GameObject menu)
        {
            if (menu == null)
            {
                Debug.LogWarning(
                    $"{nameof(MenuSelector)}.{nameof(SelectMenu)}: {nameof(menu)} was null and could not be selected.");

                return;
            }

            s_SelectedMenu.SetActive(false);
            s_SelectedMenu = menu;
            s_SelectedMenu.SetActive(true);
            m_BackButton.SetActive(s_SelectedMenu.gameObject != gameObject);

            s_SelectedMenuInfo.gameObjectName = menu.name;
        }

        public void ResetTitleLabel()
        {
            m_TitleLabel.text = k_DefaultTitleLabel;
            s_SelectedMenuInfo.menuName = null;
        }

        public void SetTitleLabelMenuName(string menuName)
        {
            m_TitleLabel.text = $"Samples / {menuName}";
            s_SelectedMenuInfo.menuName = menuName;
        }

        class MenuInfo
        {
            public string gameObjectName { get; set; }
            public string menuName { get; set; }

            public MenuInfo(string gameObjectName, string menuName)
            {
                this.gameObjectName = gameObjectName;
                this.menuName = menuName;
            }
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/MenuSelector.cs.meta
================
fileFormatVersion: 2
guid: 5e8573f1575524f7d8e181506ba7db35
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/MetaDisplayRefreshRateDropdown.cs
================
using System;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using Unity.Collections;
#if METAOPENXR_0_2_OR_NEWER && UNITY_ANDROID
using UnityEngine.XR.OpenXR.Features.Meta;
#endif

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class MetaDisplayRefreshRateDropdown : MonoBehaviour
    {
        [SerializeField]
        TMP_Dropdown m_Dropdown;

        [SerializeField]
        TextMeshProUGUI m_CurrentRefreshRateLabel;

        XRDisplaySubsystem m_DisplaySubsystem;
        NativeArray<float> m_DisplayRefreshRates;
        float m_ChosenDisplayRefreshRate;

        void Reset()
        {
            TryInitializeSerializedFields();
        }

        void Awake()
        {
            if (m_Dropdown == null)
                TryInitializeSerializedFields();
        }

        void Start()
        {
            if (!SubsystemsUtility.TryGetLoadedSubsystem<XRDisplaySubsystem, XRDisplaySubsystem>(out m_DisplaySubsystem))
            {
                Debug.LogError(
                    $"No {nameof(XRDisplaySubsystem)} is loaded. {nameof(MetaDisplayRefreshRateDropdown)} will have no effect.",
                    this);

                enabled = false;
                return;
            }

#if UNITY_EDITOR || !UNITY_ANDROID
            Debug.LogError($"{nameof(MetaDisplayRefreshRateDropdown)} is only supported on the Android platform.", this);
            enabled = false;
            return;
#elif METAOPENXR_0_2_OR_NEWER
            if (!OpenXRUtility.IsOpenXRFeatureEnabled<DisplayUtilitiesFeature>())
            {
                Debug.LogError(
                    $"{DisplayUtilitiesFeature.displayName} is not enabled. {nameof(MetaDisplayRefreshRateDropdown)} will have no effect.",
                    this);

                enabled = false;
                return;
            }

            m_Dropdown.onValueChanged.AddListener(delegate { OnDropdownValueChanged(m_Dropdown); });
            StartCoroutine(PopulateDropdown());

#else
            Debug.LogError($"{nameof(MetaDisplayRefreshRateDropdown)} requires the package com.unity.xr.meta-openxr", this);
            enabled = false;
            return;
#endif
        }

        void Update()
        {
            if (m_CurrentRefreshRateLabel != null && m_DisplaySubsystem.TryGetDisplayRefreshRate(out var currentRefreshRate))
            {
                m_CurrentRefreshRateLabel.text = $"Current display refresh rate: {currentRefreshRate} Hz";
            }
        }

        void OnDropdownValueChanged(TMP_Dropdown dropdown)
        {
#if METAOPENXR_0_2_OR_NEWER && UNITY_ANDROID
            if (!enabled)
                return;

            int index = dropdown.value;
            m_ChosenDisplayRefreshRate = m_DisplayRefreshRates[index];
            if (m_DisplaySubsystem.TryGetDisplayRefreshRate(out var currentRefreshRate))
            {
                if (!ApproximatelyEqual(currentRefreshRate, m_ChosenDisplayRefreshRate))
                    m_DisplaySubsystem.TryRequestDisplayRefreshRate(m_ChosenDisplayRefreshRate);
            }
            else
            {
                Debug.LogWarning("Failed to get current display refresh rate.", this);
                m_DisplaySubsystem.TryRequestDisplayRefreshRate(m_ChosenDisplayRefreshRate);
            }
#endif
        }

        IEnumerator PopulateDropdown()
        {
            yield return null;

#if METAOPENXR_0_2_OR_NEWER && UNITY_ANDROID
            if (!m_DisplaySubsystem.TryGetSupportedDisplayRefreshRates(Allocator.Persistent, out m_DisplayRefreshRates))
                yield break;

            var dropdownItems = new List<string>();
            foreach (var rate in m_DisplayRefreshRates)
            {
                dropdownItems.Add($"{rate} Hz");
            }
            m_Dropdown.AddOptions(dropdownItems);

            if (m_DisplaySubsystem.TryGetDisplayRefreshRate(out var currentRefreshRate))
            {
                for (int i = 0; i < m_DisplayRefreshRates.Length; ++i)
                {
                    if (ApproximatelyEqual(currentRefreshRate, m_DisplayRefreshRates[i]))
                    {
                        m_Dropdown.value = i;
                    }
                }
            }
#endif
        }

        void OnDestroy()
        {
            if (m_DisplayRefreshRates.IsCreated)
                m_DisplayRefreshRates.Dispose();
        }

        /// <summary>
        /// Actual display refresh rates can be off by a factor of tenths
        /// </summary>
        static bool ApproximatelyEqual(float a, float b)
        {
            return Mathf.Abs(a - b) < 1;
        }

        [ContextMenu("Try Initialize Serialized Fields")]
        void TryInitializeSerializedFields()
        {
            m_Dropdown = GetComponentInChildren<TMP_Dropdown>();
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/MetaDisplayRefreshRateDropdown.cs.meta
================
fileFormatVersion: 2
guid: 45fa68949d1e5426193a0e5a5dc96c5b

================
File: Assets/Scripts/Runtime/UI/RadioButton.cs
================
using System.Collections.Generic;
using TMPro;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// A simple radio button system for use with Unity UI Buttons.
    /// </summary>
    public class RadioButton : MonoBehaviour
    {
        [SerializeField]
        ColorAsset m_DeselectedColor;

        [SerializeField]
        ColorAsset m_SelectedColor;

        [SerializeField]
        TextMeshProUGUI m_Text;

        [SerializeField]
        bool m_SelectOnStart;

        [SerializeField]
        List<GameObject> m_ShowWhenSelected = new();

        static RadioButton s_SelectedButton;

        void Reset()
        {
            TryInitializeSerializedFields();
        }

        void Start()
        {
            if (m_SelectOnStart)
                Select();
        }

        public void Select()
        {
            if (s_SelectedButton != null)
                s_SelectedButton.Deselect();

            m_Text.color = m_SelectedColor.color;
            foreach (var g in m_ShowWhenSelected)
            {
                g.SetActive(true);
            }

            s_SelectedButton = this;
        }

        public void Deselect()
        {
            m_Text.color = m_DeselectedColor.color;
            foreach (var g in m_ShowWhenSelected)
            {
                g.SetActive(false);
            }

            s_SelectedButton = null;
        }

        [ContextMenu("Try Initialize Serialized Fields")]
        void TryInitializeSerializedFields()
        {
            m_Text = GetComponentInChildren<TextMeshProUGUI>();
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/RadioButton.cs.meta
================
fileFormatVersion: 2
guid: 2ab4e1ae72d7147a2906237ad85ccf18
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/RectTransformExtensions.cs
================
namespace UnityEngine.XR.ARFoundation.Samples
{
    public static class RectTransformExtensions
    {
        static readonly Vector2 s_TopCenterAnchorPosition = new(.5f, 1);

        public static void SetSize(this RectTransform rt, Vector2 size)
        {
            var oldSize = rt.rect.size;
            var deltaSize = size - oldSize;
            rt.offsetMin -= new Vector2(deltaSize.x * rt.pivot.x, deltaSize.y * rt.pivot.y);
            rt.offsetMax += new Vector2(deltaSize.x * (1f - rt.pivot.x), deltaSize.y * (1f - rt.pivot.y));
        }

        public static float GetWidth(this RectTransform rt)
        {
            return rt.rect.width;
        }

        public static void SetWidth(this RectTransform rt, float width)
        {
            SetSize(rt, new Vector2(width, rt.rect.size.y));
        }

        public static float GetHeight(this RectTransform rt)
        {
            return rt.rect.height;
        }

        public static void SetHeight(this RectTransform rt, float height)
        {
            SetSize(rt, new Vector2(rt.rect.size.x, height));
        }

        public static void SetTopLeftPosition(this RectTransform rt, Vector2 pos)
        {
            rt.localPosition = new Vector3(
                pos.x + (rt.pivot.x * rt.rect.width),
                pos.y - ((1f - rt.pivot.y) * rt.rect.height),
                rt.localPosition.z);
        }

        public static void SetTopCenterPosition(this RectTransform rt, Vector2 pos)
        {
            rt.localPosition = new Vector3(
                pos.x + (rt.pivot.x * rt.rect.width / 2),
                pos.y - ((1f - rt.pivot.y) * rt.rect.height),
                rt.localPosition.z);
        }

        public static void TranslateX(this RectTransform rt, float x)
        {
            Vector3 pos = rt.localPosition;
            rt.localPosition = new Vector3(
                pos.x + x,
                pos.y,
                pos.z);
        }

        public static void TranslateY(this RectTransform rt, float y)
        {
            Vector3 pos = rt.localPosition;
            rt.localPosition = new Vector3(
                pos.x,
                pos.y + y,
                pos.z);
        }

        public static void Translate(this RectTransform rt, Vector2 translation)
        {
            Vector3 pos = rt.localPosition;
            rt.localPosition = new Vector3(
                pos.x + translation.x,
                pos.y + translation.y,
                pos.z);
        }


        public static void AnchorToTopCenter(this RectTransform rt)
        {
            rt.anchorMin = s_TopCenterAnchorPosition;
            rt.anchorMax = s_TopCenterAnchorPosition;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/RectTransformExtensions.cs.meta
================
fileFormatVersion: 2
guid: e16c1bca6b3da49918ea433ef0b3c446
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements.meta
================
fileFormatVersion: 2
guid: c985e311cd9614addac7278a854c6291
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/IBooleanExpression.cs
================
using System.Collections.Generic;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public interface IBooleanExpression
    {
        bool Evaluate();
    }

    public static class BooleanExpressionListExtensions
    {
        /// <summary>
        /// Returns <see langword="true"/> if all expressions in the list evaluate to true.
        /// Otherwise, returns <see langword="false"/>.
        /// </summary>
        /// <param name="expressions">The expressions to evaluate.</param>
        public static bool EvaluateAll(this IList<IBooleanExpression> expressions)
        {
            foreach (var ex in expressions)
            {
                if (!ex.Evaluate())
                    return false;
            }

            return true;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/IBooleanExpression.cs.meta
================
fileFormatVersion: 2
guid: 2b266b079028487d9f83e9beb3e06f49
timeCreated: 1701116902

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresAnchors.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresAnchors : RequiresARSubsystem<XRAnchorSubsystem, XRAnchorSubsystemDescriptor>
    {
        [SerializeField]
        bool m_RequiresSaveAnchor;

        [SerializeField]
        bool m_RequiresLoadAnchor;

        [SerializeField]
        bool m_RequiresEraseAnchor;

        [SerializeField]
        bool m_RequiresGetSavedAnchorIds;

        [SerializeField]
        bool m_RequiresAsyncCancellation;

        public override bool Evaluate()
        {
            if (!base.Evaluate())
                return false;

            var descriptor = s_LoadedSubsystem.subsystemDescriptor;

            if (m_RequiresSaveAnchor && !descriptor.supportsSaveAnchor)
                return false;

            if (m_RequiresLoadAnchor && !descriptor.supportsLoadAnchor)
                return false;

            if (m_RequiresEraseAnchor && !descriptor.supportsEraseAnchor)
                return false;

            if (m_RequiresGetSavedAnchorIds && !descriptor.supportsGetSavedAnchorIds)
                return false;

            if (m_RequiresAsyncCancellation && !descriptor.supportsAsyncCancellation)
                return false;

            return true;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresAnchors.cs.meta
================
fileFormatVersion: 2
guid: e4c88408882c84730b748615f7afeaa8
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresArKitSession.cs
================
#if UNITY_IOS && !UNITY_EDITOR
using UnityEngine.XR.ARKit;
#endif

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresArKitSession : RequiresSession
    {
        [SerializeField]
        bool m_RequiresWorldMap;

        [SerializeField]
        bool m_RequiresGeoAnchors;

        [SerializeField]
        bool m_RequiresCollaborativeParticipants;

        [SerializeField]
        bool m_RequiresCoachingOverlay;

        public override bool Evaluate()
        {
            if (!base.Evaluate())
                return false;

#if !UNITY_IOS || UNITY_EDITOR
            return false;
#endif

#pragma warning disable 0162 // disable unreachable code warning in Editor
#if UNITY_IOS && !UNITY_EDITOR
            if (m_RequiresWorldMap && !ARKitSessionSubsystem.worldMapSupported)
                return false;

            if (m_RequiresGeoAnchors && !EnableGeoAnchors.IsSupported)
                return false;

            if (m_RequiresCollaborativeParticipants && !ARKitSessionSubsystem.supportsCollaboration)
                return false;

            if (m_RequiresCoachingOverlay && !ARKitSessionSubsystem.coachingOverlaySupported)
                return false;
#endif // UNITY_IOS && !UNITY_EDITOR

            return true;
#pragma warning restore 0162
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresArKitSession.cs.meta
================
fileFormatVersion: 2
guid: a2eeed5fdcd2041e29df95d3f0e4f35d
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresARSubsystem.cs
================
using System;
using System.Collections.Generic;
using UnityEngine.SubsystemsImplementation;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [Serializable]
    public abstract class RequiresARSubsystem<TSubsystem, TSubsystemDescriptor> : IBooleanExpression
        where TSubsystem : SubsystemWithProvider
        where TSubsystemDescriptor : ISubsystemDescriptor
    {
        // ReSharper disable once StaticMemberInGenericType
        static bool s_Initialized;
        static List<TSubsystemDescriptor> s_Descriptors = new();

        protected static TSubsystem s_LoadedSubsystem;

        public virtual bool Evaluate()
        {
            if (!s_Initialized)
            {
                s_Initialized = true;
                SubsystemManager.GetSubsystemDescriptors(s_Descriptors);
                s_LoadedSubsystem = LoaderUtility.GetActiveLoader()?.GetLoadedSubsystem<TSubsystem>();
            }

            return s_LoadedSubsystem != null && s_Descriptors.Count != 0;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresARSubsystem.cs.meta
================
fileFormatVersion: 2
guid: e2e0baeede4c243539a573e7da9ca2ff
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresBodyTracking.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresBodyTracking : RequiresARSubsystem<XRHumanBodySubsystem, XRHumanBodySubsystemDescriptor>
    {
        [SerializeField]
        bool m_Requires2DTracking;

        [SerializeField]
        bool m_Requires3DTracking;

        public override bool Evaluate()
        {
            if (!base.Evaluate())
                return false;

            var descriptor = s_LoadedSubsystem.subsystemDescriptor;

            if (m_Requires2DTracking && !descriptor.supportsHumanBody2D)
                return false;

            if (m_Requires3DTracking && !descriptor.supportsHumanBody3D)
                return false;

            return true;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresBodyTracking.cs.meta
================
fileFormatVersion: 2
guid: a28f4ffd054424fdaaa280480ef1a484
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresBoundingBoxes.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresBoundingBoxes : RequiresARSubsystem<XRBoundingBoxSubsystem, XRBoundingBoxSubsystemDescriptor>
    {
        [SerializeField]
        bool m_RequiresBoundingBoxClassifications;

        public override bool Evaluate()
        {
            if (!base.Evaluate())
                return false;

            var descriptor = s_LoadedSubsystem.subsystemDescriptor;

            if (m_RequiresBoundingBoxClassifications && !descriptor.supportsClassifications)
                return false;

            return true;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresBoundingBoxes.cs.meta
================
fileFormatVersion: 2
guid: 7a9a4deb83cb4558945af672394ac3c0
timeCreated: 1706220984

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresCamera.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresCamera : RequiresARSubsystem<XRCameraSubsystem, XRCameraSubsystemDescriptor>
    {
        [SerializeField]
        bool m_RequiresCameraImages;

        [SerializeField]
        bool m_RequiresBasicLightEstimation;

        [SerializeField]
        bool m_RequiresHdrLightEstimation;

        [SerializeField]
        bool m_RequiresCameraGrain;

        [SerializeField]
        bool m_RequiresExifData;

        [SerializeField]
        bool m_RequiresImageStabilization;

        public override bool Evaluate()
        {
            if (!base.Evaluate())
                return false;

            var descriptor = s_LoadedSubsystem.subsystemDescriptor;

            if (m_RequiresCameraImages && !descriptor.supportsCameraImage)
                return false;

            if (m_RequiresBasicLightEstimation)
            {
                bool supportsBasics = descriptor.supportsCameraConfigurations && descriptor.supportsCameraImage;
                bool supportsColor = descriptor.supportsAverageColorTemperature || descriptor.supportsColorCorrection;
                bool supportsBrightness = descriptor.supportsAverageBrightness || descriptor.supportsAverageIntensityInLumens;

                if (!(supportsBasics && supportsColor && supportsBrightness))
                    return false;
            }

            if (m_RequiresHdrLightEstimation)
            {
                if (!(descriptor.supportsFaceTrackingHDRLightEstimation || descriptor.supportsWorldTrackingHDRLightEstimation))
                    return false;
            }

            if (m_RequiresCameraGrain && !descriptor.supportsCameraGrain)
                return false;

            if (m_RequiresExifData && !descriptor.supportsExifData)
                return false;

            if (m_RequiresImageStabilization && descriptor.supportsImageStabilization == Supported.Unsupported)
                return false;

            return true;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresCamera.cs.meta
================
fileFormatVersion: 2
guid: 554debc3f2b7f4fdba06c75541f8ccef
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresEnvironmentProbes.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresEnvironmentProbes : RequiresARSubsystem<XREnvironmentProbeSubsystem, XREnvironmentProbeSubsystemDescriptor>
    { }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresEnvironmentProbes.cs.meta
================
fileFormatVersion: 2
guid: 396427124b6e6488081eda1d820f2424
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresFaceTracking.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresFaceTracking : RequiresARSubsystem<XRFaceSubsystem, XRFaceSubsystemDescriptor>
    {
        [SerializeField]
        bool m_RequiresEyeTracking;

        public override bool Evaluate()
        {
            if (!base.Evaluate())
                return false;

            if (m_RequiresEyeTracking && !s_LoadedSubsystem.subsystemDescriptor.supportsEyeTracking)
                return false;

            return true;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresFaceTracking.cs.meta
================
fileFormatVersion: 2
guid: 91c49eba589b94537a487c9b3c4b93a9
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresImageTracking.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresImageTracking : RequiresARSubsystem<XRImageTrackingSubsystem, XRImageTrackingSubsystemDescriptor>
    { }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresImageTracking.cs.meta
================
fileFormatVersion: 2
guid: 085d2e3d1f18442a594ed38334ea94d6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresMeshing.cs
================
using System;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [Serializable]
    public class RequiresMeshing : IBooleanExpression
    {
        static bool s_MeshingSupported;
        static bool s_MeshingChecked;

        public bool Evaluate()
        {
            if (!s_MeshingChecked)
            {
                s_MeshingChecked = true;
                var activeLoader = LoaderUtility.GetActiveLoader();
                if(activeLoader && activeLoader.GetLoadedSubsystem<XRMeshSubsystem>() != null)
                    s_MeshingSupported = true;
            }

            return s_MeshingSupported;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresMeshing.cs.meta
================
fileFormatVersion: 2
guid: 609510bf3ee9e404ca1f5e5307b26ad5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresObjectTracking.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresObjectTracking : RequiresARSubsystem<XRObjectTrackingSubsystem, XRObjectTrackingSubsystemDescriptor>
    { }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresObjectTracking.cs.meta
================
fileFormatVersion: 2
guid: 156aac8a4181349e2ae9a91b371a1998
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresOcclusion.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresOcclusion : RequiresARSubsystem<XROcclusionSubsystem, XROcclusionSubsystemDescriptor>
    {
        [SerializeField]
        bool m_RequiresDepth;

        public override bool Evaluate()
        {
            if (!base.Evaluate())
                return false;

            var descriptor = s_LoadedSubsystem.subsystemDescriptor;

            if (m_RequiresDepth && 
                descriptor.environmentDepthImageSupported == Supported.Unsupported &&
                descriptor.humanSegmentationDepthImageSupported == Supported.Unsupported &&
                descriptor.humanSegmentationStencilImageSupported == Supported.Unsupported)
            {
                return false;
            }

            return true;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresOcclusion.cs.meta
================
fileFormatVersion: 2
guid: a76114b409f1149098afdc47e2ad0838
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresParticipants.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresParticipants : RequiresARSubsystem<XRParticipantSubsystem, XRParticipantSubsystemDescriptor>
    { }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresParticipants.cs.meta
================
fileFormatVersion: 2
guid: 0343d56a04647433ea3c9d3e43cbd12c
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresPlaneDetection.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresPlaneDetection : RequiresARSubsystem<XRPlaneSubsystem, XRPlaneSubsystemDescriptor>
    {
        [SerializeField]
        bool m_RequiresPlaneClassifications;

        public override bool Evaluate()
        {
            if (!base.Evaluate())
                return false;

            var descriptor = s_LoadedSubsystem.subsystemDescriptor;

            if (m_RequiresPlaneClassifications && !descriptor.supportsClassification)
                return false;

            return true;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresPlaneDetection.cs.meta
================
fileFormatVersion: 2
guid: 14366ccbec5df480db79d56937a938f0
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresPlatform.cs
================
using System;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [Serializable]
    public class RequiresPlatform : IBooleanExpression
    {
        enum Platform { iOS, Android }

        [SerializeField]
        Platform m_RequiredPlatform;

        [SerializeField]
        VersionRequirement m_VersionRequirement;

        [SerializeField]
        bool m_AllowEditor;

        public bool Evaluate()
        {
#if !UNITY_IOS
            if (m_RequiredPlatform == Platform.iOS)
                return false;

#elif !UNITY_ANDROID
            if (m_RequiredPlatform == Platform.Android)
                return false;
#endif

            if (Application.isEditor && !m_AllowEditor)
                return false;

#if UNITY_IOS
            if (m_VersionRequirement.requiresMinimumVersion)
            {
                string version = iOS.Device.systemVersion;
                int major = int.Parse(version.Split(".")[0]);
                if (major < m_VersionRequirement.minimumVersion)
                    return false;
            }
#endif
            return true;
        }

        [Serializable]
        public struct VersionRequirement
        {
            public bool requiresMinimumVersion;
            public int minimumVersion;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresPlatform.cs.meta
================
fileFormatVersion: 2
guid: 36c9d6b1454ff451bbabc7f46bdd59a4
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresPointClouds.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresPointClouds : RequiresARSubsystem<XRPointCloudSubsystem, XRPointCloudSubsystemDescriptor>
    { }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresPointClouds.cs.meta
================
fileFormatVersion: 2
guid: 40d86858ef0d9421790d06a6f64a43b6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresRaycasts.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresRaycasts : RequiresARSubsystem<XRRaycastSubsystem, XRRaycastSubsystemDescriptor>
    { }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresRaycasts.cs.meta
================
fileFormatVersion: 2
guid: b15ca82550f884eda8c39dfaa5167f04
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresSession.cs
================
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class RequiresSession : RequiresARSubsystem<XRSessionSubsystem, XRSessionSubsystemDescriptor>
    { }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresSession.cs.meta
================
fileFormatVersion: 2
guid: b3dfc2e75b2c44b1689f0d0895b0d528
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresVisualScripting.cs
================
using System;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [Serializable]
    public class RequiresVisualScripting : IBooleanExpression
    {
        public bool Evaluate()
        {
#if VISUALSCRIPTING_1_8_OR_NEWER
            return true;
#endif
#pragma warning disable CS0162
            return false;
#pragma warning restore CS0162
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/RequiresVisualScripting.cs.meta
================
fileFormatVersion: 2
guid: a7179764bda8241e0a9a87b6365486b2
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Requirements/SampleSceneDescriptor.cs
================
using System.Collections.Generic;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [CreateAssetMenu(menuName = "XR/AR Foundation/Sample Scene Descriptor")]
    public class SampleSceneDescriptor : ScriptableObject
    {
        [SerializeField]
        string m_SceneName;
        public string sceneName => m_SceneName;

        [SerializeReference, SelectImplementation(typeof(IBooleanExpression))]
        List<IBooleanExpression> m_Requirements;
        public IList<IBooleanExpression> requirements => m_Requirements;

        public bool EvaluateRequirements()
        {
            bool areRequirementsMet = true;
            foreach (var r in m_Requirements)
            {
                if (!r.Evaluate())
                {
                    areRequirementsMet = false;
                    break;
                }
            }

            return areRequirementsMet;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Requirements/SampleSceneDescriptor.cs.meta
================
fileFormatVersion: 2
guid: adf2a45713b8498389fc5c57560f14d1
timeCreated: 1701141716

================
File: Assets/Scripts/Runtime/UI/SceneLauncher.cs
================
using System;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [RequireComponent(typeof(Button))]
    [DisallowMultipleComponent]
    public class SceneLauncher : MonoBehaviour
    {
        [SerializeField]
        SampleSceneDescriptor m_SceneDescriptor;
        public SampleSceneDescriptor sceneDescriptor => m_SceneDescriptor;

        [SerializeField, HideInInspector]
        Button m_Button;

        void OnEnable()
        {
            if (sceneDescriptor.EvaluateRequirements())
                m_Button.onClick.AddListener(LaunchScene);
            else
                m_Button.SetEnabled(false);
        }

        void OnDisable()
        {
            m_Button.onClick.RemoveListener(LaunchScene);
        }

        public void LaunchScene()
        {
            if (m_SceneDescriptor == null)
            {
                Debug.LogError("Scene Descriptor is null. Cannot launch scene", this);
                return;
            }

            if (!m_SceneDescriptor.EvaluateRequirements())
            {
                Debug.LogError($"Cannot launch scene {m_SceneDescriptor.sceneName} because it is not supported on this device.");
                return;
            }

            SceneManager.LoadScene(m_SceneDescriptor.sceneName, LoadSceneMode.Single);
        }

        void Reset()
        {
            m_Button = GetComponent<Button>();
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/SceneLauncher.cs.meta
================
fileFormatVersion: 2
guid: e950fc6e83464e5d8331e626c2036ec0
timeCreated: 1701119798

================
File: Assets/Scripts/Runtime/UI/ScreenOrientationLock.cs
================
using System;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [DisallowMultipleComponent]
    public class ScreenOrientationLock : MonoBehaviour
    {
#pragma warning disable 0414
        [SerializeField, Tooltip("The orientation to lock the screen while this component is enabled.")]
        ScreenOrientation m_LockOrientation = ScreenOrientation.Portrait;
#pragma warning restore 0414

#if !UNITY_EDITOR
        void OnEnable()
        {
            if (!MenuLoader.IsHmdDevice())
                Screen.orientation = m_LockOrientation;
        }

        void OnDisable()
        {
            if (!MenuLoader.IsHmdDevice())
                Screen.orientation = ScreenOrientation.AutoRotation;
        }
#endif
    }
}

================
File: Assets/Scripts/Runtime/UI/ScreenOrientationLock.cs.meta
================
fileFormatVersion: 2
guid: 6d89770f3485c4abeaee31000709e3e5
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/ScreenSpaceUIWorkaround.cs
================
using System.Collections.Generic;
using UnityEngine.Rendering;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Hacky workaround for bug where screen space UI is not rendered in scenes with
    /// no camera. Disables screen space UI Overlay for current render pipeline, forcing 
    /// rendering at the end on native side so screen space UI canvas doesn't appear 
    /// on output test image.
    /// </summary>
    public class ScreenSpaceUIWorkaround : MonoBehaviour
    {
        void Start()
        {
            RenderPipelineManager.beginContextRendering += OnBeginContextRendering;
        }

        void OnBeginContextRendering(ScriptableRenderContext context, List<Camera> cameras)
        {
            SupportedRenderingFeatures.active.rendersUIOverlay = false;
        }

        void OnDestroy()
        {
            RenderPipelineManager.beginContextRendering -= OnBeginContextRendering;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/ScreenSpaceUIWorkaround.cs.meta
================
fileFormatVersion: 2
guid: e3bf89230b534fb40b1069f8944a48be

================
File: Assets/Scripts/Runtime/UI/SelectImplementationAttribute.cs
================
using System;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Use the attribute in combination with SerializeReference to select a concrete implementation type of a field
    /// in the Inspector.
    /// </summary>
    [AttributeUsage(AttributeTargets.Field)]
    public class SelectImplementationAttribute : PropertyAttribute
    {
        public Type fieldType { get; }

        public SelectImplementationAttribute(Type fieldType)
        {
            this.fieldType = fieldType;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/SelectImplementationAttribute.cs.meta
================
fileFormatVersion: 2
guid: afaadde12eb54ad093a1ced7f878d277
timeCreated: 1701120544

================
File: Assets/Scripts/Runtime/UI/TableLayout.cs
================
using System;
using System.Collections.Generic;
using System.Linq;
#if UNITY_EDITOR
using UnityEditor;
#endif

namespace UnityEngine.XR.ARFoundation.Samples
{
    [RequireComponent(typeof(RectTransform))]
    public class TableLayout : MonoBehaviour
    {
        enum Alignment { Left, Center }

        RectTransform m_RectTransform;

        [SerializeField]
        List<RectTransform> m_Cells = new();

        [SerializeField]
        Alignment m_Alignment = Alignment.Center;

        [SerializeField, Range(1, 5)]
        int m_Columns = 3;

        [SerializeField, Range(1, 1250)]
        int m_CellWidth = 340;

        [SerializeField, Range(1, 1250)]
        int m_CellHeight = 115;

        [SerializeField, Range(1, 400)]
        int m_CellPadding = 30;

        void OnEnable()
        {
#if UNITY_EDITOR
            EditorApplication.delayCall += Refresh;
#endif
        }

        void OnValidate()
        {
#if UNITY_EDITOR
            EditorApplication.delayCall += Refresh;
#endif
        }

        void Awake()
        {
            Refresh();
        }

        void Refresh()
        {
            // Can happen if this GameObject was marked for destroy before the Editor delay call executes
            if (this == null)
                return;

            if (m_RectTransform == null)
               m_RectTransform = GetComponent<RectTransform>();

            ResetCells();
            RegenerateLayout();
        }

        void ResetCells()
        {
            foreach (RectTransform cell in m_Cells.Where(cell => cell != null))
            {
                cell.localScale = Vector3.one;
                cell.SetWidth(m_CellWidth);
                cell.SetHeight(m_CellHeight);
            }
        }

        void RegenerateLayout()
        {
            var rect = m_RectTransform.rect;
            var xCenter = rect.xMin + rect.width / 2;
            for (var i = 0; i < Mathf.CeilToInt((float)m_Cells.Count / m_Columns); i++)
            {
                for (var j = 0; j < m_Columns; j++)
                {
                    var index = i * m_Columns + j;
                    if (index > m_Cells.Count - 1)
                        break;

                    var cell = m_Cells[index];

                    float xLeft = 0;
                    switch (m_Alignment)
                    {
                        case Alignment.Left:
                            xLeft = rect.xMin;
                            break;
                        case Alignment.Center when m_Columns % 2 == 0:
                            xLeft =
                                xCenter
                                - (m_Columns / 2 * m_CellWidth) // subtract cells left of center
                                - Mathf.FloorToInt((m_Columns / 2 - .5f) * m_CellPadding); // subtract padding
                            break;
                        case Alignment.Center:
                            xLeft =
                                xCenter
                                - (m_Columns / 2 * m_CellPadding) // subtract padding left of center
                                - Mathf.FloorToInt((m_Columns / 2 + .5f) * m_CellWidth); // subtract cells
                            break;
                        default:
                            throw new ArgumentOutOfRangeException();
                    }
                    
                    cell.AnchorToTopCenter();
                    cell.SetTopLeftPosition(new Vector2(
                        xLeft + j * (m_CellWidth + m_CellPadding), 
                        rect.yMax - i * (m_CellHeight + m_CellPadding)));
                }
            }
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/TableLayout.cs.meta
================
fileFormatVersion: 2
guid: 172fa646d7f914e29aa0c78d0bffd6ef
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/TestAnchorScrollViewEntry.cs
================
using System;
using System.Threading;
using System.Threading.Tasks;
using TMPro;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;
using UnityEngine.XR.ARSubsystems;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class TestAnchorScrollViewEntry : MonoBehaviour
    {
        [Header("Entry References")]
        [SerializeField]
        Button m_SaveButton;

        [SerializeField]
        Button m_LoadButton;

        [SerializeField]
        Button m_EraseButton;

        [SerializeField]
        TextMeshProUGUI m_AnchorDisplayLabel;
        public string AnchorDisplayText => m_AnchorDisplayLabel.text;

        [Header("Save Button References")]
        [SerializeField]
        GameObject m_SaveButtonText;

        [SerializeField]
        GameObject m_SaveButtonIcon;

        [SerializeField]
        LoadingVisualizer m_SaveLoadingVisualizer;

        [SerializeField]
        GameObject m_SaveSuccessVisualizer;

        [SerializeField]
        GameObject m_SaveErrorVisualizer;

        [Header("Lopad Button References")]
        [SerializeField]
        GameObject m_LoadButtonText;

        [SerializeField]
        GameObject m_LoadButtonIcon;
        
        [SerializeField]
        LoadingVisualizer m_LoadLoadingVisualizer;

        [SerializeField]
        GameObject m_LoadSuccessVisualizer;

        [SerializeField]
        GameObject m_LoadErrorVisualizer;

        [Header("Erase Button References")]
        [SerializeField]
        GameObject m_EraseButtonIcon;

        [SerializeField]
        LoadingVisualizer m_EraseLoadingVisualizer;
        
        [SerializeField]
        GameObject m_EraseSuccessVisualizer;

        [SerializeField]
        GameObject m_EraseErrorVisualizer;

        public ARAnchor representedAnchor { get; set; }

        public SerializableGuid persistentAnchorGuid { get; set; }

        [SerializeField, Tooltip("The event raised when the action button is clicked.")]
        UnityEvent<TestAnchorScrollViewEntry> m_RequestSave = new();
        public UnityEvent<TestAnchorScrollViewEntry> requestSave => m_RequestSave;

        [SerializeField, Tooltip("The event raised when the action button is clicked.")]
        UnityEvent<TestAnchorScrollViewEntry> m_RequestLoad = new();
        public UnityEvent<TestAnchorScrollViewEntry> requestLoad => m_RequestLoad;
        
        [SerializeField, Tooltip("The event raised when the erase button is clicked.")]
        UnityEvent<TestAnchorScrollViewEntry> m_RrequestEraseAnchor = new();
        public UnityEvent<TestAnchorScrollViewEntry> requestEraseAnchor => m_RrequestEraseAnchor;

        CancellationTokenSource m_CancellationTokenSource = new();

        public void StartSaveLoadingAnimation()
        {
            m_SaveButtonText.SetActive(false);
            m_SaveButtonIcon.SetActive(false);
            m_SaveLoadingVisualizer.StartAnimating();
        }

        public void StopSaveLoadingAnimation()
        {
            m_SaveLoadingVisualizer.StopAnimating();
            m_SaveButtonIcon.SetActive(true);
            m_SaveButtonText.SetActive(true);
        }
        
        public void StartLoadLoadingAnimation()
        {
            m_LoadButtonText.SetActive(false);
            m_LoadButtonIcon.SetActive(false);
            m_LoadLoadingVisualizer.StartAnimating();
        }

        public void StopLoadLoadingAnimation()
        {
            m_LoadLoadingVisualizer.StopAnimating();
            m_LoadButtonIcon.SetActive(true);
            m_LoadButtonText.SetActive(true);
        }
        
        public void StartEraseLoadingAnimation()
        {
            m_EraseButtonIcon.SetActive(false);
            m_EraseLoadingVisualizer.StartAnimating();
        }

        public void StopEraseLoadingAnimation()
        {
            m_EraseLoadingVisualizer.StopAnimating();
            m_EraseButtonIcon.SetActive(true);
        }

        public async Task ShowSaveResult(bool isSuccessful, float durationInSeconds)
        {
            var visualizer = isSuccessful ? m_SaveSuccessVisualizer : m_SaveErrorVisualizer;
            visualizer.SetActive(true);
            m_SaveButtonText.SetActive(false);
            m_SaveButtonIcon.SetActive(false);

            try
            {
                await Task.Delay((int)(durationInSeconds * 1000), m_CancellationTokenSource.Token);
            }
            catch (OperationCanceledException)
            {
                // do nothing
            }

            visualizer.SetActive(false);
            m_SaveButtonText.SetActive(true);
            m_SaveButtonIcon.SetActive(true);
        }
        
        public async Task ShowLoadResult(bool isSuccessful, float durationInSeconds)
        {
            var visualizer = isSuccessful ? m_LoadSuccessVisualizer : m_LoadErrorVisualizer;
            visualizer.SetActive(true);
            m_LoadButtonText.SetActive(false);
            m_LoadButtonIcon.SetActive(false);

            try
            {
                await Task.Delay((int)(durationInSeconds * 1000), m_CancellationTokenSource.Token);
            }
            catch (OperationCanceledException)
            {
                // do nothing
            }

            visualizer.SetActive(false);
            m_LoadButtonText.SetActive(true);
            m_LoadButtonIcon.SetActive(true);
        }

        public async Task ShowEraseResult(bool isSuccessful, float durationInSeconds)
        {
            var visualizer = isSuccessful ? m_EraseSuccessVisualizer : m_EraseErrorVisualizer;
            visualizer.SetActive(true);
            m_EraseButtonIcon.SetActive(false);

            try
            {
                await Task.Delay((int)(durationInSeconds * 1000), m_CancellationTokenSource.Token);
            }
            catch (OperationCanceledException)
            {
                // do nothing
            }

            visualizer.SetActive(false);
            m_EraseButtonIcon.SetActive(true);
        }

        public void SetDisplayedAnchorLabel(string label)
        {
            m_AnchorDisplayLabel.text = label;
        }

        void OnEnable()
        {
            m_CancellationTokenSource = new();
            m_SaveButton.onClick.AddListener(OnRequestSaveButtonClicked);
            m_LoadButton.onClick.AddListener(OnRequestLoadButtonClicked);
            m_EraseButton.onClick.AddListener(OnEraseAnchorButtonClicked);
        }

        void OnDisable()
        {
            m_SaveButton.onClick.RemoveListener(OnRequestSaveButtonClicked);
            m_LoadButton.onClick.RemoveListener(OnRequestLoadButtonClicked);
            m_EraseButton.onClick.RemoveListener(OnEraseAnchorButtonClicked);
            m_CancellationTokenSource.Cancel();
        }

        void OnDestroy()
        {
            m_SaveButton.onClick.RemoveAllListeners();
            m_LoadButton.onClick.RemoveAllListeners();
            m_EraseButton.onClick.RemoveAllListeners();
        }

        void OnRequestSaveButtonClicked()
        {
            m_RequestSave?.Invoke(this);
        }

        void OnRequestLoadButtonClicked()
        {
            m_RequestLoad?.Invoke(this);
        }

        void OnEraseAnchorButtonClicked()
        {
            m_RrequestEraseAnchor?.Invoke(this);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/TestAnchorScrollViewEntry.cs.meta
================
fileFormatVersion: 2
guid: 40b80dc3f31df4731aa0aae60c26441d

================
File: Assets/Scripts/Runtime/UI/Tooltip.cs
================
using UnityEngine.EventSystems;
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public class Tooltip : MonoBehaviour, IPointerEnterHandler, IPointerExitHandler
    {
        [SerializeField]
        GameObject m_Tooltip;
        public GameObject toolTip
        {
            get { return m_Tooltip; }
            set { m_Tooltip = value; }
        }
        bool m_EnteredButton;

        void Update()
        {
            if(m_EnteredButton)
            {
                m_Tooltip.transform.position = transform.position;
            }
        }

        public void OnPointerEnter(PointerEventData eventData)
        {
            m_EnteredButton = true;
            if(!gameObject.GetComponent<Button>().interactable)
            {
                m_Tooltip.SetActive(true);
            }
        }

        public void OnPointerExit(PointerEventData eventData)
        {
            m_EnteredButton = false;
            m_Tooltip.SetActive(false);
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/Tooltip.cs.meta
================
fileFormatVersion: 2
guid: 16733cd6749cf4d96be9df0329c6938a
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/UI/Touchable.cs
================
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// Empty Graphic type, useful for creating invisible buttons.
    /// </summary>
    public class Touchable : Text
    {
        // empty class does nothing
    }
}

================
File: Assets/Scripts/Runtime/UI/Touchable.cs.meta
================
fileFormatVersion: 2
guid: d7bc994beb06a4917bf3bd7e6a35d44d

================
File: Assets/Scripts/Runtime/UI/UIScrollViewVerticalScrollController.cs
================
using System;
using UnityEngine;
using UnityEngine.UI;

namespace UnityEngine.XR.ARFoundation.Samples
{
    [RequireComponent(typeof(ScrollRect))]
    public class UIScrollViewVerticalScrollController : MonoBehaviour
    {
        [SerializeField, HideInInspector]
        ScrollRect m_ScrollView;
        
        [SerializeField]
        RectTransform m_Viewport;

        [SerializeField]
        RectTransform m_Content;

        void Reset() => m_ScrollView = GetComponent<ScrollRect>();

        void Start()
        {
            if (m_ScrollView == null)
                m_ScrollView = GetComponent<ScrollRect>();
        }

        void Update()
        {
            var viewportHeight = m_Viewport.rect.size.y;
            var contentHeight = m_Content.rect.size.y;

            m_ScrollView.vertical = contentHeight > viewportHeight;
        }
    }
}

================
File: Assets/Scripts/Runtime/UI/UIScrollViewVerticalScrollController.cs.meta
================
fileFormatVersion: 2
guid: 835e1584f4c15464583ff09d09c937e0

================
File: Assets/Scripts/Runtime/Unity.XR.ARFoundation.Samples.asmdef
================
{
    "name": "Unity.XR.ARFoundation.Samples",
    "rootNamespace": "UnityEngine.XR.ARFoundation.Samples",
    "references": [
        "Unity.XR.ARFoundation",
        "Unity.InputSystem",
        "Unity.XR.ARSubsystems",
        "Unity.XR.CoreUtils",
        "Unity.TextMeshPro",
        "Unity.XR.Interaction.Toolkit",
        "Unity.XR.Management",
        "Unity.XR.ARKit",
        "Unity.XR.ARKit.FaceTracking",
        "Unity.XR.ARCore",
        "Unity.VisualScripting.Core",
        "Unity.VisualScripting.Flow",
        "Unity.XR.MetaOpenXR",
        "Unity.XR.OpenXR"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": true,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "com.unity.visualscripting",
            "expression": "1.8",
            "define": "VISUALSCRIPTING_1_8_OR_NEWER"
        },
        {
            "name": "com.unity.xr.meta-openxr",
            "expression": "0.2.0",
            "define": "METAOPENXR_0_2_OR_NEWER"
        }
    ],
    "noEngineReferences": false
}

================
File: Assets/Scripts/Runtime/Unity.XR.ARFoundation.Samples.asmdef.meta
================
fileFormatVersion: 2
guid: f66fb68e117ee411d9e6e94f5622b192
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Util.meta
================
fileFormatVersion: 2
guid: d6dda0a951d634b95b86c527f0ff6c6c
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Util/LogComponent.cs
================
namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// A component to log something. This is useful to debug whether a Button.onClicked event is triggering.
    /// </summary>
    public class LogComponent : MonoBehaviour
    {
        public void Log(string s)
        {
            Debug.Log(s);
        }
    }
}

================
File: Assets/Scripts/Runtime/Util/LogComponent.cs.meta
================
fileFormatVersion: 2
guid: afb02102229f643f2a25c936e5061bce
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/Util/OpenXRUtility.cs
================
using System.Runtime.CompilerServices;
using UnityEngine.XR.OpenXR;
using UnityEngine.XR.OpenXR.Features;

namespace UnityEngine.XR.ARFoundation.Samples
{
    static class OpenXRUtility
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool IsOpenXRFeatureEnabled<T>() where T : OpenXRFeature
        {
            var feature = OpenXRSettings.Instance.GetFeature<T>() ;
            return feature != null && feature.enabled;
        }
    }
}

================
File: Assets/Scripts/Runtime/Util/OpenXRUtility.cs.meta
================
fileFormatVersion: 2
guid: 63b9747c6de6d41d3bac3bf13fb446f1

================
File: Assets/Scripts/Runtime/Util/SubsystemsUtility.cs
================
using UnityEngine.XR.Management;

namespace UnityEngine.XR.ARFoundation.Samples
{
    public static class SubsystemsUtility
    {
        public static bool TryGetLoadedSubsystem<TSubsystemBase, TSubsystemConcrete>(out TSubsystemConcrete subsystem)
            where TSubsystemBase : class, ISubsystem
            where TSubsystemConcrete : class, TSubsystemBase
        {
            if (XRGeneralSettings.Instance == null || XRGeneralSettings.Instance.Manager == null)
            {
                subsystem = null;
                return false;
            }

            var loader = XRGeneralSettings.Instance.Manager.activeLoader;
            var asBaseSubsystem = loader != null ? loader.GetLoadedSubsystem<TSubsystemBase>() : null;
            subsystem = asBaseSubsystem as TSubsystemConcrete;
            return subsystem != null;
        }
    }
}

================
File: Assets/Scripts/Runtime/Util/SubsystemsUtility.cs.meta
================
fileFormatVersion: 2
guid: a0bbdf0a161e54be3ac08f41c7e542f1

================
File: Assets/Scripts/Runtime/VisualScripting.meta
================
fileFormatVersion: 2
guid: acc76b1ee0d394a1c9825a8d5dba2f7f
folderAsset: yes
DefaultImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/VisualScripting/AssemblyInfo.cs
================
#if VISUALSCRIPTING_1_8_OR_NEWER
using UnityEngine.Scripting;

[assembly: AlwaysLinkAssembly, Preserve]
#endif

================
File: Assets/Scripts/Runtime/VisualScripting/AssemblyInfo.cs.meta
================
fileFormatVersion: 2
guid: 22f9a54100b6b42319829ac582002cd6
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/VisualScripting/EventAssetEventUnit.cs
================
#if VISUALSCRIPTING_1_8_OR_NEWER
using System;
using System.Collections.Generic;
using Unity.VisualScripting;

namespace UnityEngine.XR.ARFoundation.Samples.VisualScripting
{
    /// <summary>
    /// Custom <see cref="EventUnit{TArgs}"/> that triggers when the input <see cref="EventAsset"/> is raised.
    /// </summary>
    [UnitTitle(k_UnitTitle)]
    [UnitCategory("Events/AR Foundation/Samples")]
    public sealed class EventAssetEventUnit : EventUnit<EventArgs>
    {
        const string k_UnitTitle = "On EventAsset Raised";

        /// <summary>
        /// Set this to true if this unit will listen for its event on the visual scripting event bus.
        /// </summary>
        /// <remarks>
        /// This unit directly subscribes to the input <c>EventAsset</c> and does not need to listen for anything
        /// from the event bus.
        /// </remarks>
        protected override bool register => false;

        Dictionary<GraphReference, EventHandler> m_DelegateClosures = new();

        /// <summary>
        /// The input <see cref="EventAsset"/>.
        /// </summary>
        [DoNotSerialize]
        public ValueInput eventAsset { get; private set; }

        /// <summary>
        /// Defines the unit.
        /// </summary>
        protected override void Definition()
        {
            base.Definition();
            eventAsset = ValueInput<EventAsset>(nameof(eventAsset));
        }

        /// <summary>
        /// Fired when this unit should start listening for its event.
        /// </summary>
        /// <param name="stack">The <c>GraphStack</c>.</param>
        public override void StartListening(GraphStack stack)
        {
            base.StartListening(stack);

            var graphReference = stack.AsReference();
            var asset = GetEventAsset(graphReference);
            if (asset == null)
                return;

            void OnEventRaised(object sender, EventArgs args) { Trigger(graphReference); }
            asset.eventRaised += OnEventRaised;
            m_DelegateClosures.Add(graphReference, OnEventRaised);
        }

        EventAsset GetEventAsset(GraphReference graphReference)
        {
            if (!eventAsset.hasAnyConnection)
            {
                Debug.LogError($"{k_UnitTitle} node has no input connection. Make sure there is a non-null {nameof(EventAsset)}.");
                return null;
            }
        
            var flow = Flow.New(graphReference);
            var asset = flow.GetValue(eventAsset) as EventAsset;
            if (asset == null)
                Debug.LogError($"{k_UnitTitle} node has an invalid input connection. Make sure there is a non-null {nameof(EventAsset)}");

            flow.Dispose();
            return asset;
        }

        void Trigger(GraphReference graphReference)
        {
            var flow = Flow.New(graphReference);
            flow.Run(trigger);
        }

        /// <summary>
        /// Fired when this unit should stop listening for its event.
        /// </summary>
        /// <param name="stack">The <c>GraphStack</c>.</param>
        public override void StopListening(GraphStack stack)
        {
            base.StopListening(stack);

            var graphReference = stack.AsReference();
            if (!m_DelegateClosures.ContainsKey(graphReference))
                return;

            var asset = GetEventAsset(graphReference);
            var action = m_DelegateClosures[graphReference];
            asset.eventRaised -= action;
            m_DelegateClosures.Remove(graphReference);
        }
    }
}
#endif // VISUALSCRIPTING_1_8_OR_NEWER

================
File: Assets/Scripts/Runtime/VisualScripting/EventAssetEventUnit.cs.meta
================
fileFormatVersion: 2
guid: ebf9c3da9781a46329651886f508ad61
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/VisualScripting/PointerPressedEventUnit.cs
================
#if VISUALSCRIPTING_1_8_OR_NEWER

using System;
using Unity.VisualScripting;
using UnityEngine.InputSystem;

namespace UnityEngine.XR.ARFoundation.Samples.VisualScripting
{
    [UnitTitle("On Input System Pointer Pressed")]
    [UnitCategory("Events/AR Foundation/Samples")]
    [UnitOrder(1)]
    public class PointerPressedEventUnit : EventUnit<Vector2>
    {
        const string k_PointerPressedEventHook = "Pointer Pressed";

        protected sealed override bool register => true;

        [DoNotSerialize]
        public ValueOutput pointerPosition { get; private set; }

        public override EventHook GetHook(GraphReference _) => k_PointerPressedEventHook;

        protected override void Definition()
        {
            base.Definition();
            pointerPosition = ValueOutput<Vector2>(nameof(pointerPosition));
        }

        public override void StartListening(GraphStack stack)
        {
            base.StartListening(stack);
            PointerPressedListener.instance.Enable();
        }

        public override void StopListening(GraphStack stack)
        {
            base.StopListening(stack);
            PointerPressedListener.instance.Disable();
        }

        protected override void AssignArguments(Flow flow, Vector2 arg)
        {
            flow.SetValue(pointerPosition, arg);
        }

        class PointerPressedListener
        {
            public static PointerPressedListener instance => m_Instance ??= new PointerPressedListener();
            static PointerPressedListener m_Instance;

            InputAction s_PressAction;

            PointerPressedListener()
            {
                s_PressAction = new InputAction(k_PointerPressedEventHook, binding: "<Pointer>/press");
                s_PressAction.performed += ctx =>
                {
                    if (ctx.control.device is Pointer device)
                    {
                        EventBus.Trigger(k_PointerPressedEventHook, device.position.ReadValue());
                    }
                };
                s_PressAction.Enable();
            }

            public void Enable()
            {
                s_PressAction.Enable();
            }

            public void Disable()
            {
                s_PressAction.Disable();
            }
        }
    }
}

#endif // VISUALSCRIPTING_1_8_OR_NEWER

================
File: Assets/Scripts/Runtime/VisualScripting/PointerPressedEventUnit.cs.meta
================
fileFormatVersion: 2
guid: 035b396237edf415ab195035bdfd91cb
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/VisualScripting/Unity.XR.ARFoundation.Samples.VisualScripting.asmdef
================
{
    "name": "Unity.XR.ARFoundation.Samples.VisualScripting",
    "rootNamespace": "UnityEngine.XR.ARFoundation.Samples.VisualScripting",
    "references": [
        "Unity.VisualScripting.Core",
        "Unity.VisualScripting.Flow",
        "Unity.InputSystem",
        "Unity.XR.ARFoundation.Samples"
    ],
    "includePlatforms": [],
    "excludePlatforms": [],
    "allowUnsafeCode": false,
    "overrideReferences": false,
    "precompiledReferences": [],
    "autoReferenced": true,
    "defineConstraints": [],
    "versionDefines": [
        {
            "name": "com.unity.visualscripting",
            "expression": "1.8.0",
            "define": "VISUALSCRIPTING_1_8_OR_NEWER"
        }
    ],
    "noEngineReferences": false
}

================
File: Assets/Scripts/Runtime/VisualScripting/Unity.XR.ARFoundation.Samples.VisualScripting.asmdef.meta
================
fileFormatVersion: 2
guid: b38f1e536c1c145c1a3f25710a2cd83a
AssemblyDefinitionImporter:
  externalObjects: {}
  userData: 
  assetBundleName: 
  assetBundleVariant:

================
File: Assets/Scripts/Runtime/XROriginExtensions.cs
================
using System;
using Unity.XR.CoreUtils;
using UnityEngine;

namespace UnityEngine.XR.ARFoundation.Samples
{
    /// <summary>
    /// This class contains extension methods suitable for replacing the <c>ARSessionOrigin.MakeContentAppearAt</c>
    /// API as existed in AR Foundation 4.2, allowing users to upgrade projects from
    /// <see cref="ARSessionOrigin"/> to <see cref="XROrigin"/> with continued access to this API. 
    /// </summary>
    public static class XROriginExtensions
    {
        /// <summary>
        /// Makes <paramref name="content"/> appear to be placed at <paramref name="position"/> with orientation <paramref name="rotation"/>.
        /// </summary>
        /// <param name="origin">The <c>XROrigin</c> in the Scene.</param>
        /// <param name="content">The <c>Transform</c> of the content you wish to affect.</param>
        /// <param name="position">The position you wish the content to appear at. This could be
        /// a position on a detected plane, for example.</param>
        /// <param name="rotation">The rotation the content should appear to be in, relative
        /// to the <c>Camera</c>.</param>
        /// <remarks>
        /// This method does not actually change the <c>Transform</c> of content; instead,
        /// it updates the <c>XROrigin</c>'s <c>Transform</c> so the content
        /// appears to be at the given position and rotation. This is useful for placing AR
        /// content onto surfaces when the content itself cannot be moved at runtime.
        /// For example, if your content includes terrain or a NavMesh, it cannot
        /// be moved or rotated dynamically.
        /// </remarks>
        public static void MakeContentAppearAt(this XROrigin origin, Transform content, Vector3 position, Quaternion rotation)
        {
            MakeContentAppearAt(origin, content, position);
            MakeContentAppearAt(origin, content, rotation);
        }

        /// <summary>
        /// Makes <paramref name="content"/> appear to be placed at <paramref name="position"/>.
        /// </summary>
        /// <param name="origin">The <c>XROrigin</c> in the Scene.</param>
        /// <param name="content">The <c>Transform</c> of the content you wish to affect.</param>
        /// <param name="position">The position you wish the content to appear at. This could be
        /// a position on a detected plane, for example.</param>
        /// <remarks>
        /// This method does not actually change the <c>Transform</c> of content; instead,
        /// it updates the <c>XROrigin</c>'s <c>Transform</c> so the content
        /// appears to be at the given position.
        /// </remarks>
        public static void MakeContentAppearAt(this XROrigin origin, Transform content, Vector3 position)
        {
            if (content == null)
                throw new ArgumentNullException(nameof(content));

            var originTransform = origin.transform;
            
            // Adjust the Camera Offset transform to account
            // for the actual position we want the content to appear at.
            origin.CameraFloorOffsetObject.transform.position += originTransform.position - position;

            // The XROrigin's position needs to match the content's pivot. This is so
            // the entire XROrigin rotates around the content (so the impression is that
            // the content is rotating, not the rig).
            originTransform.position = content.position;
        }

        /// <summary>
        /// Makes <paramref name="content"/> appear to have orientation <paramref name="rotation"/> relative to the <c>Camera</c>.
        /// </summary>
        /// <param name="origin">The <c>XROrigin</c> in the Scene.</param>
        /// <param name="content">The <c>Transform</c> of the content you wish to affect.</param>
        /// <param name="rotation">The rotation the content should appear to be in, relative
        /// to the <c>Camera</c>.</param>
        /// <remarks>
        /// This method does not actually change the <c>Transform</c> of content; instead,
        /// it updates the <c>XROrigin</c>'s <c>Transform</c> so that the content
        /// appears to be in the requested orientation.
        /// </remarks>
        public static void MakeContentAppearAt(this XROrigin origin, Transform content, Quaternion rotation)
        {
            if (content == null)
                throw new ArgumentNullException(nameof(content));

            // Since we aren't rotating the content, we need to perform the inverse
            // operation on the XROrigin. For example, if we want the
            // content to appear to be rotated 90 degrees on the Y axis, we should
            // rotate our rig -90 degrees on the Y axis.
            origin.transform.rotation = Quaternion.Inverse(rotation) * content.rotation;
        }
    }
}

================
File: Assets/Scripts/Runtime/XROriginExtensions.cs.meta
================
fileFormatVersion: 2
guid: 77c8c888846de438fb44705dfdfb2d71
MonoImporter:
  externalObjects: {}
  serializedVersion: 2
  defaultReferences: []
  executionOrder: 0
  icon: {instanceID: 0}
  userData: 
  assetBundleName: 
  assetBundleVariant:
